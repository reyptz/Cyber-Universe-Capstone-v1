# Constraint Templates OPA/Gatekeeper pour Ghost Cyber Universe
# Politiques de sécurité automatisées

---
# Template pour vérifier les images non-root
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  name: k8srequirednonroot
  annotations:
    description: "Require containers to run as non-root user"
    security.ghost-cyber-universe.com/policy: "required"
spec:
  crd:
    spec:
      names:
        kind: K8sRequiredNonRoot
      validation:
        type: object
        properties:
          message:
            type: string
          severity:
            type: string
            enum: ["error", "warning"]
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package k8srequirednonroot
        
        violation[{"msg": msg}] {
          container := input.review.object.spec.containers[_]
          container.securityContext.runAsUser
          container.securityContext.runAsUser == 0
          msg := sprintf("Container '%v' must not run as root (runAsUser: %v)", [container.name, container.securityContext.runAsUser])
        }
        
        violation[{"msg": msg}] {
          container := input.review.object.spec.containers[_]
          not container.securityContext.runAsUser
          msg := sprintf("Container '%v' must specify runAsUser (non-zero)", [container.name])
        }
---
# Template pour vérifier les capabilities
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  name: k8srequiredcapabilities
  annotations:
    description: "Require containers to drop all capabilities"
    security.ghost-cyber-universe.com/policy: "required"
spec:
  crd:
    spec:
      names:
        kind: K8sRequiredCapabilities
      validation:
        type: object
        properties:
          message:
            type: string
          severity:
            type: string
            enum: ["error", "warning"]
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package k8srequiredcapabilities
        
        violation[{"msg": msg}] {
          container := input.review.object.spec.containers[_]
          not container.securityContext.capabilities
          msg := sprintf("Container '%v' must specify securityContext.capabilities", [container.name])
        }
        
        violation[{"msg": msg}] {
          container := input.review.object.spec.containers[_]
          container.securityContext.capabilities
          not container.securityContext.capabilities.drop
          msg := sprintf("Container '%v' must drop all capabilities", [container.name])
        }
        
        violation[{"msg": msg}] {
          container := input.review.object.spec.containers[_]
          container.securityContext.capabilities
          container.securityContext.capabilities.drop
          not "ALL" in container.securityContext.capabilities.drop
          msg := sprintf("Container '%v' must drop ALL capabilities", [container.name])
        }
---
# Template pour vérifier les ressources
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  name: k8srequiredresources
  annotations:
    description: "Require containers to specify resource limits and requests"
    security.ghost-cyber-universe.com/policy: "required"
spec:
  crd:
    spec:
      names:
        kind: K8sRequiredResources
      validation:
        type: object
        properties:
          message:
            type: string
          severity:
            type: string
            enum: ["error", "warning"]
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package k8srequiredresources
        
        violation[{"msg": msg}] {
          container := input.review.object.spec.containers[_]
          not container.resources
          msg := sprintf("Container '%v' must specify resources", [container.name])
        }
        
        violation[{"msg": msg}] {
          container := input.review.object.spec.containers[_]
          container.resources
          not container.resources.requests
          msg := sprintf("Container '%v' must specify resource requests", [container.name])
        }
        
        violation[{"msg": msg}] {
          container := input.review.object.spec.containers[_]
          container.resources
          not container.resources.limits
          msg := sprintf("Container '%v' must specify resource limits", [container.name])
        }
---
# Template pour vérifier les images sécurisées
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  name: k8srequiredsecureimages
  annotations:
    description: "Require containers to use secure images from approved registries"
    security.ghost-cyber-universe.com/policy: "required"
spec:
  crd:
    spec:
      names:
        kind: K8sRequiredSecureImages
      validation:
        type: object
        properties:
          message:
            type: string
          severity:
            type: string
            enum: ["error", "warning"]
          allowedRegistries:
            type: array
            items:
              type: string
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package k8srequiredsecureimages
        
        violation[{"msg": msg}] {
          container := input.review.object.spec.containers[_]
          not container.image
          msg := sprintf("Container '%v' must specify an image", [container.name])
        }
        
        violation[{"msg": msg}] {
          container := input.review.object.spec.containers[_]
          container.image
          not startswith(container.image, "ghcr.io/")
          not startswith(container.image, "docker.io/")
          not startswith(container.image, "quay.io/")
          msg := sprintf("Container '%v' must use image from approved registry", [container.name])
        }
        
        violation[{"msg": msg}] {
          container := input.review.object.spec.containers[_]
          container.image
          endswith(container.image, ":latest")
          msg := sprintf("Container '%v' must not use 'latest' tag", [container.name])
        }
---
# Template pour vérifier les NetworkPolicies
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  name: k8srequirednetworkpolicies
  annotations:
    description: "Require namespaces to have NetworkPolicies"
    security.ghost-cyber-universe.com/policy: "required"
spec:
  crd:
    spec:
      names:
        kind: K8sRequiredNetworkPolicies
      validation:
        type: object
        properties:
          message:
            type: string
          severity:
            type: string
            enum: ["error", "warning"]
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package k8srequirednetworkpolicies
        
        violation[{"msg": msg}] {
          namespace := input.review.object.metadata.namespace
          namespace != "kube-system"
          namespace != "kube-public"
          namespace != "kube-node-lease"
          namespace != "gatekeeper-system"
          not data.inventory.namespace[namespace]
          msg := sprintf("Namespace '%v' must have NetworkPolicies", [namespace])
        }
---
# Template pour vérifier les secrets
apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  name: k8srequiredsecrets
  annotations:
    description: "Require secrets to be properly configured"
    security.ghost-cyber-universe.com/policy: "required"
spec:
  crd:
    spec:
      names:
        kind: K8sRequiredSecrets
      validation:
        type: object
        properties:
          message:
            type: string
          severity:
            type: string
            enum: ["error", "warning"]
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package k8srequiredsecrets
        
        violation[{"msg": msg}] {
          secret := input.review.object
          secret.kind == "Secret"
          secret.type == "Opaque"
          not secret.data
          msg := sprintf("Secret '%v' must have data", [secret.metadata.name])
        }
        
        violation[{"msg": msg}] {
          secret := input.review.object
          secret.kind == "Secret"
          secret.type == "Opaque"
          secret.data
          not secret.metadata.annotations["security.ghost-cyber-universe.com/encrypted"]
          msg := sprintf("Secret '%v' must be encrypted", [secret.metadata.name])
        }

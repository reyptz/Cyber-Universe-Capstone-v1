<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Générateur de Clés - Ghost Cyber Universe</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    <link href="/static/css/ghost-dark.css" rel="stylesheet">
    <!-- zxcvbn for password strength -->
    <script src="https://unpkg.com/zxcvbn@4.2.0/dist/zxcvbn.js" defer></script>
    <!-- QR Code generation -->
    <script src="https://unpkg.com/qrcode@1.5.3/build/qrcode.min.js" defer></script>
    <!-- JSZip for ZIP export -->
    <script src="https://unpkg.com/jszip@3.10.1/dist/jszip.min.js" defer></script>
    
    <!-- Custom styles for preview panel -->
    <style>
        .preview-item, .metric-item {
            padding: 0.75rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 0.5rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }
        
        .preview-item:hover, .metric-item:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(255, 0, 0, 0.3);
            transform: translateY(-2px);
        }
        
        .preview-item label, .metric-item label {
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 0.25rem;
        }
        
        .security-score-excellent { color: #28a745 !important; }
        .security-score-good { color: #17a2b8 !important; }
        .security-score-fair { color: #ffc107 !important; }
        .security-score-poor { color: #dc3545 !important; }
        
        .progress-bar.bg-excellent { background: linear-gradient(90deg, #28a745, #20c997) !important; }
        .progress-bar.bg-good { background: linear-gradient(90deg, #17a2b8, #6f42c1) !important; }
        .progress-bar.bg-fair { background: linear-gradient(90deg, #ffc107, #fd7e14) !important; }
        .progress-bar.bg-poor { background: linear-gradient(90deg, #dc3545, #e83e8c) !important; }
        
        .recommendation-item {
            padding: 0.5rem;
            margin: 0.25rem 0;
            border-radius: 0.25rem;
            border-left: 3px solid;
            background: rgba(255, 255, 255, 0.03);
        }
        
        .recommendation-item.recommendation-good {
            border-left-color: #28a745;
            background: rgba(40, 167, 69, 0.1);
        }
        
        .recommendation-item.recommendation-warning {
            border-left-color: #ffc107;
            background: rgba(255, 193, 7, 0.1);
        }
        
        .recommendation-item.recommendation-danger {
            border-left-color: #dc3545;
            background: rgba(220, 53, 69, 0.1);
        }
        
        .code-example {
            font-family: 'JetBrains Mono', 'Courier New', monospace;
            font-size: 0.8rem;
            line-height: 1.4;
        }
        
        .performance-badge {
            display: inline-block;
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .performance-fast { background: rgba(40, 167, 69, 0.2); color: #28a745; }
        .performance-medium { background: rgba(255, 193, 7, 0.2); color: #ffc107; }
        .performance-slow { background: rgba(220, 53, 69, 0.2); color: #dc3545; }
        
        .animate-pulse {
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        /* Styles pour l'historique des clés */
        .history-list {
            max-height: 400px;
            overflow-y: auto;
            padding-right: 0.5rem;
        }
        
        .history-list::-webkit-scrollbar {
            width: 6px;
        }
        
        .history-list::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
        }
        
        .history-list::-webkit-scrollbar-thumb {
            background: rgba(255, 0, 0, 0.5);
            border-radius: 3px;
        }
        
        .history-item {
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 0.5rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
            cursor: pointer;
        }
        
        .history-item:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(255, 0, 0, 0.3);
            transform: translateY(-2px);
        }
        
        .history-item.active {
            background: rgba(255, 0, 0, 0.1);
            border-color: rgba(255, 0, 0, 0.5);
        }
        
        .history-item-header {
            display: flex;
            justify-content: between;
            align-items: center;
            margin-bottom: 0.5rem;
        }
        
        .history-item-type {
            font-weight: 600;
            color: #ff0000;
            font-size: 0.9rem;
        }
        
        .history-item-time {
            font-size: 0.75rem;
            color: #888;
        }
        
        .history-item-details {
            font-size: 0.8rem;
            color: #ccc;
            line-height: 1.4;
        }
        
        .history-item-actions {
            display: flex;
            gap: 0.25rem;
            margin-top: 0.5rem;
        }
        
        .history-item-actions .btn {
            padding: 0.25rem 0.5rem;
            font-size: 0.7rem;
        }
        
        .key-fingerprint {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            color: #888;
            word-break: break-all;
        }
        
        .security-badge {
            display: inline-block;
            padding: 0.125rem 0.375rem;
            border-radius: 0.25rem;
            font-size: 0.65rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .security-excellent { background: rgba(40, 167, 69, 0.2); color: #28a745; }
        .security-good { background: rgba(23, 162, 184, 0.2); color: #17a2b8; }
        .security-fair { background: rgba(255, 193, 7, 0.2); color: #ffc107; }
        .security-poor { background: rgba(220, 53, 69, 0.2); color: #dc3545; }
        
        /* Styles pour les détails des clés */
        .key-details {
            background: rgba(255, 255, 255, 0.03);
            border-radius: 0.5rem;
            padding: 1rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .detail-item {
            margin-bottom: 0.75rem;
        }
        
        .detail-item:last-child {
            margin-bottom: 0;
        }
        
        .detail-item label {
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 0.25rem;
        }
        
        /* Styles pour les onglets avancés */
        .nav-ghost .nav-link {
            color: #888;
            border: 1px solid transparent;
            border-radius: 0.5rem 0.5rem 0 0;
            background: rgba(255, 255, 255, 0.05);
            transition: all 0.3s ease;
        }
        
        .nav-ghost .nav-link:hover {
            color: #fff;
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 0, 0, 0.3);
        }
        
        .nav-ghost .nav-link.active {
            color: #ff0000;
            background: rgba(255, 0, 0, 0.1);
            border-color: rgba(255, 0, 0, 0.5);
            border-bottom-color: transparent;
        }
        
        /* Styles pour les cartes de monitoring */
        .monitoring-card {
            padding: 1rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 0.5rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
            text-align: center;
            transition: all 0.3s ease;
        }
        
        .monitoring-card:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(255, 0, 0, 0.3);
            transform: translateY(-2px);
        }
        
        .monitoring-value {
            font-size: 2rem;
            font-weight: 700;
            color: #ff0000;
            margin: 0.5rem 0;
        }
        
        .monitoring-label {
            font-size: 0.8rem;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        /* Styles pour les métriques de performance */
        .performance-metric, .security-analytics {
            padding: 0.75rem;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 0.5rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }
        
        .performance-metric:hover, .security-analytics:hover {
            background: rgba(255, 255, 255, 0.05);
            border-color: rgba(255, 0, 0, 0.2);
        }
        
        /* Styles pour les cartes de statistiques */
        .stat-card {
            padding: 1.5rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 0.75rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
            text-align: center;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .stat-card:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(255, 0, 0, 0.3);
            transform: translateY(-3px);
        }
        
        .stat-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 0, 0, 0.1), transparent);
            transition: left 0.5s ease;
        }
        
        .stat-card:hover::before {
            left: 100%;
        }
        
        .stat-icon {
            font-size: 2rem;
            margin-bottom: 1rem;
            opacity: 0.8;
        }
        
        .stat-value {
            font-size: 2.5rem;
            font-weight: 700;
            color: #ff0000;
            margin-bottom: 0.5rem;
        }
        
        .stat-label {
            font-size: 0.9rem;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        /* Animation pour les onglets */
        .tab-pane {
            animation: fadeInUp 0.5s ease-out;
        }
        
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
    </style>
</head>
<body>
    <!-- Cyber Effects -->
    <div class="cyber-scan-line" aria-hidden="true"></div>
    <div class="cyber-grid-bg" aria-hidden="true"></div>

    <!-- Navigation -->
    <nav class="navbar navbar-expand-lg navbar-dark fixed-top">
        <div class="container">
            <a class="navbar-brand" href="/">
                <i class="fas fa-ghost me-2"></i>
                Ghost Cyber Universe
            </a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav ms-auto">
                    <li class="nav-item">
                        <a class="nav-link" href="/">Accueil</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link active" href="/generate" aria-current="page">Générer</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/security">Sécurité</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/about">À Propos</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link" href="/api/docs">API Docs</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <!-- Header with Progress Feedback -->
    <header class="py-5 section-cyber" role="banner">
        <div class="container">
            <div class="row text-center">
                <div class="col-lg-8 mx-auto mt-5">
                    <div class="animate-fade-in-down">
                        <div class="d-inline-flex align-items-center justify-content-center mb-4">
                            <div class="feature-icon glow-pulse me-3" style="width: 60px; height: 60px;">
                                <i class="fas fa-key" aria-hidden="true"></i>
                            </div>
                            <h1 class="text-gradient mb-0 glitch-effect" data-text="Générateur Sécurisé de Clés">Générateur Sécurisé de Clés</h1>
                        </div>
                        <p class="lead text-ghost-secondary animate-fade-in-up delay-200">
                            Configurez et générez des clés conformes aux meilleures pratiques. Feedback en temps réel pour une UX fluide.
                        </p>
                        <div class="progress-ghost mt-3 mx-auto" style="width: 70%; height: 6px;" role="progressbar" aria-label="Progression de configuration" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">
                            <div class="progress-bar bg-gradient-cyber" id="configProgress" style="width: 0%;"></div>
                        </div>
                        <small class="text-ghost-muted d-block mt-1" id="progressText">Progression : 0/5 étapes</small>
                    </div>
                </div>
            </div>
        </div>
    </header>

    <!-- Main Form Section with Real-time Validation -->
    <main class="py-5 section-cyber-darker" role="main">
        <div class="container">
            <div class="row g-5">
                <!-- Enhanced Form with ARIA and Validation -->
                <div class="col-lg-6">
                    <div class="card-cyber hologram-effect animate-fade-in-left h-100">
                        <div class="card-body p-4">
                            <div class="d-flex align-items-center mb-4">
                                <i class="fas fa-cogs text-glow me-3 text-blackhat-green" aria-hidden="true"></i>
                                <h2 class="text-ghost-primary mb-0">Configuration de la Clé</h2>
                            </div>
                            
                            <form id="keyGenerationForm" novalidate>
                                <!-- Type de clé -->
                                <div class="mb-4">
                                    <label for="keyType" class="form-label text-ghost-secondary">
                                        <i class="fas fa-key me-2" aria-hidden="true"></i>Type de Clé
                                    </label>
                                    <select class="form-select form-select-ghost" id="keyType" name="key_type" required aria-describedby="keyTypeHelp" aria-invalid="false">
                                        <option value="">Sélectionnez un type de clé...</option>
                                        <option value="symmetric">Clés Symétriques</option>
                                        <option value="rsa">RSA (Legacy)</option>
                                        <option value="ecc">ECC (Courbes Elliptiques)</option>
                                        <option value="ed25519">Ed25519</option>
                                        <option value="x25519">X25519</option>
                                        <option value="ssh">Clés SSH</option>
                                        <option value="tls_cert">Certificats TLS</option>
                                        <option value="bip39">BIP39 (Crypto-monnaie)</option>
                                        <option value="jwt">JWT/API Tokens</option>
                                        <option value="hmac">HMAC</option>
                                        <option value="totp">TOTP/OTP</option>
                                        <option value="kdf">KDF (Dérivation)</option>
                                        <option value="post_quantum">Post-Quantique</option>
                                    </select>
                                    <div id="keyTypeHelp" class="form-text text-ghost-muted">
                                        Choisissez le type de clé selon votre usage (NIST 2025)
                                    </div>
                </div>

                                <!-- Algorithme -->
                                <div class="mb-4">
                                    <label for="algorithm" class="form-label text-ghost-secondary">
                                        <i class="fas fa-microchip me-2" aria-hidden="true"></i>Algorithme
                                    </label>
                                    <select class="form-select form-select-ghost" id="algorithm" name="algorithm" required disabled aria-describedby="algorithmHelp" aria-invalid="false">
                                        <option value="">Sélectionnez d'abord un type de clé</option>
                                    </select>
                                    <div id="algorithmHelp" class="form-text text-ghost-muted">
                                        Algorithme cryptographique (conforme NIST SP 800-57)
                                    </div>
                                </div>

                                <!-- Taille de clé -->
                                <div class="mb-4">
                                    <label for="keySize" class="form-label text-ghost-secondary">
                                        <i class="fas fa-ruler me-2" aria-hidden="true"></i>Taille de Clé (bits)
                                    </label>
                                    <div class="row align-items-center">
                                        <div class="col-8">
                                            <input type="range" class="form-range" id="keySizeRange" min="128" max="8192" value="256" step="64">
                                        </div>
                                        <div class="col-4">
                                            <input type="number" class="form-control form-control-ghost" id="keySize" name="key_size" value="256" min="128" max="8192" step="64" required aria-describedby="keySizeHelp" aria-invalid="false">
                                        </div>
                                    </div>
                                    <div id="keySizeHelp" class="form-text text-ghost-muted">
                                        Taille en bits (minimum 128, recommandé selon algorithme)
                                    </div>
                                </div>

                                <!-- Format de sortie -->
                                <div class="mb-4">
                                    <label for="outputFormat" class="form-label text-ghost-secondary">
                                        <i class="fas fa-file-export me-2" aria-hidden="true"></i>Format de Sortie
                                    </label>
                                    <select class="form-select form-select-ghost" id="outputFormat" name="output_format" required aria-describedby="outputFormatHelp" aria-invalid="false">
                                        <option value="pem">PEM</option>
                                        <option value="der">DER</option>
                                        <option value="base64">Base64</option>
                                        <option value="hex">Hexadécimal</option>
                                    </select>
                                    <div id="outputFormatHelp" class="form-text text-ghost-muted">
                                        Format d'export de la clé générée
                                    </div>
                                </div>

                                <!-- Protection par mot de passe -->
                                <div class="mb-4">
                                    <div class="form-check">
                                        <input class="form-check-input" type="checkbox" id="passwordProtected" name="password_protected">
                                        <label class="form-check-label text-ghost-secondary" for="passwordProtected">
                                            <i class="fas fa-shield-alt me-2" aria-hidden="true"></i>Protéger par mot de passe
                                        </label>
                                    </div>
                                </div>

                                <!-- Section mot de passe (masquée par défaut) -->
                                <div id="passwordSection" class="mb-4" style="display: none;">
                                    <label for="password" class="form-label text-ghost-secondary">
                                        <i class="fas fa-lock me-2" aria-hidden="true"></i>Mot de passe
                                    </label>
                                    <div class="input-group">
                                        <input type="password" class="form-control form-control-ghost" id="password" name="password" minlength="12" aria-describedby="passwordHelp" aria-invalid="false">
                                        <button class="btn btn-outline-secondary" type="button" id="togglePasswordBtn" aria-label="Afficher/masquer le mot de passe">
                                            <i class="fas fa-eye" aria-hidden="true"></i>
                                        </button>
                                        <button class="btn btn-outline-success" type="button" id="generatePasswordBtn" aria-label="Générer un mot de passe sécurisé">
                                            <i class="fas fa-dice" aria-hidden="true"></i>
                                        </button>
                                    </div>
                                    <div id="passwordHelp" class="form-text text-ghost-muted">
                                        Minimum 12 caractères (OWASP 2025)
                                    </div>
                                    
                                    <!-- Indicateur de force du mot de passe -->
                                    <div id="passwordStrength" class="mt-2" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="4" aria-label="Force du mot de passe">
                                        <div class="progress-ghost" style="height: 6px;">
                                            <div id="strengthBar" class="progress-bar bg-secondary" style="width: 0%;"></div>
                                        </div>
                                        <small id="strengthText" class="text-ghost-muted">Aucune</small>
                                    </div>
                                </div>

                                <!-- Paramètres spéciaux TLS -->
                                <div id="tlsParams" class="mb-4" style="display: none;">
                                    <h5 class="text-ghost-secondary mb-3">
                                        <i class="fas fa-certificate me-2" aria-hidden="true"></i>Paramètres TLS
                                    </h5>
                                    <div class="row">
                                        <div class="col-md-6 mb-3">
                                            <label for="commonName" class="form-label text-ghost-secondary">Nom Commun</label>
                                            <input type="text" class="form-control form-control-ghost" id="commonName" name="common_name" value="Ghost Cyber Universe">
                                        </div>
                                        <div class="col-md-6 mb-3">
                                            <label for="organization" class="form-label text-ghost-secondary">Organisation</label>
                                            <input type="text" class="form-control form-control-ghost" id="organization" name="organization" value="Ghost Cyber Universe">
                                        </div>
                                        <div class="col-md-6 mb-3">
                                            <label for="country" class="form-label text-ghost-secondary">Pays</label>
                                            <input type="text" class="form-control form-control-ghost" id="country" name="country" value="FR" maxlength="2">
                                        </div>
                                        <div class="col-md-6 mb-3">
                                            <label for="email" class="form-label text-ghost-secondary">Email</label>
                                            <input type="email" class="form-control form-control-ghost" id="email" name="email">
                                        </div>
                                        <div class="col-12 mb-3">
                                            <label for="validityDays" class="form-label text-ghost-secondary">Validité (jours)</label>
                                            <input type="number" class="form-control form-control-ghost" id="validityDays" name="validity_days" value="365" min="1" max="398">
                                        </div>
                                    </div>
                                </div>

                                <!-- Paramètres spéciaux KDF -->
                                <div id="kdfParams" class="mb-4" style="display: none;">
                                    <h5 class="text-ghost-secondary mb-3">
                                        <i class="fas fa-key me-2" aria-hidden="true"></i>Paramètres KDF
                                    </h5>
                                    <div class="row">
                                        <div class="col-md-6 mb-3">
                                            <label for="iterations" class="form-label text-ghost-secondary">Itérations</label>
                                            <input type="number" class="form-control form-control-ghost" id="iterations" name="iterations" value="100000" min="10000">
                                        </div>
                                        <div class="col-md-6 mb-3">
                                            <label for="saltLength" class="form-label text-ghost-secondary">Longueur du Salt (bytes)</label>
                                            <input type="number" class="form-control form-control-ghost" id="saltLength" name="salt_length" value="32" min="16">
                                        </div>
                                    </div>
                                </div>

                                <!-- Bouton de génération -->
                                <div class="d-grid">
                                    <button type="submit" class="btn btn-cyber btn-lg" id="generateBtn" disabled aria-describedby="generateBtnHelp">
                                        <span id="generateBtnText">
                                            <i class="fas fa-magic me-2" aria-hidden="true"></i>Générer la Clé
                                        </span>
                                        <span id="loadingSpinner" class="spinner-border spinner-border-sm d-none" role="status" aria-hidden="true"></span>
                                    </button>
                                    <div id="generateBtnHelp" class="form-text text-ghost-muted text-center mt-2">
                                        Configurez tous les paramètres pour activer la génération
                                    </div>
                                </div>
                            </form>
                        </div>
                    </div>
                </div>

                <!-- Real-time Preview Panel -->
                <div class="col-lg-6">
                    <div class="card-cyber hologram-effect animate-fade-in-up h-100">
                        <div class="card-body p-4 d-flex flex-column">
                            <div class="d-flex align-items-center mb-4 flex-grow-0">
                                <i class="fas fa-eye text-glow me-3 text-blackhat-green" aria-hidden="true"></i>
                                <h2 class="text-ghost-primary mb-0 flex-grow-1">Aperçu en Temps Réel</h2>
                            </div>
                            
                            <div id="previewContainer" class="flex-grow-1">
                                <!-- Configuration Preview -->
                                <div id="configPreview" class="mb-4">
                                    <div class="alert-ghost alert-ghost-info mb-3" role="status">
                                        <i class="fas fa-info-circle me-2" aria-hidden="true"></i>
                                        <strong>Configuration actuelle :</strong>
                                    </div>
                                    
                                    <div class="row g-3">
                                        <div class="col-md-6">
                                            <div class="preview-item">
                                                <label class="text-ghost-secondary small">Type de clé</label>
                                                <div id="previewKeyType" class="text-white">Non sélectionné</div>
                                            </div>
                                        </div>
                                        <div class="col-md-6">
                                            <div class="preview-item">
                                                <label class="text-ghost-secondary small">Algorithme</label>
                                                <div id="previewAlgorithm" class="text-white">Non sélectionné</div>
                                            </div>
                                        </div>
                                        <div class="col-md-6">
                                            <div class="preview-item">
                                                <label class="text-ghost-secondary small">Taille</label>
                                                <div id="previewKeySize" class="text-white">256 bits</div>
                                            </div>
                                        </div>
                                        <div class="col-md-6">
                                            <div class="preview-item">
                                                <label class="text-ghost-secondary small">Format</label>
                                                <div id="previewFormat" class="text-white">PEM</div>
                                            </div>
                                        </div>
                                    </div>
                                </div>

                                <!-- Security Audit -->
                                <div id="securityAudit" class="mb-4">
                                    <div class="alert-ghost alert-ghost-warning mb-3" role="status">
                                        <i class="fas fa-shield-alt me-2" aria-hidden="true"></i>
                                        <strong>Audit de sécurité :</strong>
                                    </div>
                                    
                                    <div id="securityScore" class="mb-3">
                                        <div class="d-flex justify-content-between align-items-center mb-2">
                                            <span class="text-ghost-secondary">Score de sécurité</span>
                                            <span id="securityScoreValue" class="text-white">0/100</span>
                                        </div>
                                        <div class="progress-ghost" style="height: 8px;">
                                            <div id="securityScoreBar" class="progress-bar bg-danger" style="width: 0%;"></div>
                                        </div>
                                    </div>
                                    
                                    <div id="securityRecommendations" class="small">
                                        <div class="text-ghost-muted">Sélectionnez un type de clé pour voir les recommandations</div>
                                    </div>
                                </div>

                                <!-- Performance Metrics -->
                                <div id="performanceMetrics" class="mb-4">
                                    <div class="alert-ghost alert-ghost-success mb-3" role="status">
                                        <i class="fas fa-tachometer-alt me-2" aria-hidden="true"></i>
                                        <strong>Métriques de performance :</strong>
                                    </div>
                                    
                                    <div class="row g-3">
                                        <div class="col-md-6">
                                            <div class="metric-item">
                                                <label class="text-ghost-secondary small">Temps estimé</label>
                                                <div id="estimatedTime" class="text-white">~1-3s</div>
                                            </div>
                                        </div>
                                        <div class="col-md-6">
                                            <div class="metric-item">
                                                <label class="text-ghost-secondary small">Taille clé</label>
                                                <div id="estimatedSize" class="text-white">~1-2 KB</div>
                                            </div>
                                        </div>
                                    </div>
                                </div>

                                <!-- Usage Examples -->
                                <div id="usageExamples" class="mb-4" style="display: none;">
                                    <div class="alert-ghost alert-ghost-primary mb-3" role="status">
                                        <i class="fas fa-code me-2" aria-hidden="true"></i>
                                        <strong>Exemples d'usage :</strong>
                                    </div>
                                    
                                    <div id="codeExamples" class="code-block-ghost">
                                        <pre class="mb-0 small"><code id="exampleCode">Sélectionnez un type de clé pour voir les exemples</code></pre>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Navigation Tabs for Advanced Features -->
            <div class="row g-5 mt-3">
                <div class="col-12">
                    <ul class="nav nav-tabs nav-ghost" id="advancedTabs" role="tablist">
                        <li class="nav-item" role="presentation">
                            <button class="nav-link active" id="history-tab" data-bs-toggle="tab" data-bs-target="#history-panel" type="button" role="tab" aria-controls="history-panel" aria-selected="true">
                                <i class="fas fa-history me-2" aria-hidden="true"></i>Historique
                            </button>
                        </li>
                    </ul>
                </div>
            </div>
            
            <div class="tab-content" id="advancedTabsContent">
                <!-- History Panel -->
                <div class="tab-pane fade show active" id="history-panel" role="tabpanel" aria-labelledby="history-tab">
                    <div class="row g-5 mt-3">
                        <!-- Key History Panel -->
                        <div class="col-lg-4">
                    <div class="card-cyber hologram-effect animate-fade-in-left h-100">
                        <div class="card-body p-4 d-flex flex-column">
                            <div class="d-flex align-items-center mb-4 flex-grow-0">
                                <i class="fas fa-history text-glow me-3 text-blackhat-green" aria-hidden="true"></i>
                                <h2 class="text-ghost-primary mb-0 flex-grow-1">Historique des Clés</h2>
                                <button class="btn btn-sm btn-outline-secondary" id="clearHistoryBtn" title="Effacer l'historique">
                                    <i class="fas fa-trash" aria-hidden="true"></i>
                                </button>
                            </div>
                            
                            <div id="keyHistoryContainer" class="flex-grow-1">
                                <div id="historyList" class="history-list">
                                    <!-- Les clés générées apparaîtront ici -->
                                </div>
                                
                                <div id="noHistoryMessage" class="text-center py-5">
                                    <i class="fas fa-key display-4 text-ghost-muted mb-3" aria-hidden="true"></i>
                                    <h5 class="text-ghost-secondary mb-2">Aucune clé générée</h5>
                                    <p class="text-ghost-muted small">L'historique de vos clés générées apparaîtra ici</p>
                                </div>
                            </div>
                            
                            <div class="mt-3">
                                <small class="text-ghost-muted">
                                    <i class="fas fa-info-circle me-1" aria-hidden="true"></i>
                                    Stockage local sécurisé (métadonnées uniquement)
                                </small>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Results Section with Copy to Clipboard -->
                <div class="col-lg-8">
                    <div class="card-cyber hologram-effect animate-fade-in-right h-100">
                        <div class="card-body p-4 d-flex flex-column">
                            <div class="d-flex align-items-center mb-4 flex-grow-0">
                                <i class="fas fa-keyboard text-glow me-3 text-blackhat-green" aria-hidden="true"></i>
                                <h2 class="text-ghost-primary mb-0 flex-grow-1">Résultats de Génération</h2>
                            </div>
                            
                            <div id="resultContainer" class="flex-grow-1 d-none" role="region" aria-live="polite">
                                <div class="alert-ghost alert-ghost-success mb-4" role="alert" aria-label="Succès génération">
                                    <i class="fas fa-check-circle me-2 text-blackhat-green" aria-hidden="true"></i>
                                    Clé générée avec succès ! Copiez et sécurisez immédiatement.
                                </div>
                                
                                <div id="resultContent" class="code-block-ghost position-relative" role="code" aria-label="Clé générée">
                                    <!-- Dynamic content injected -->
                                    <button class="btn btn-sm btn-outline-light position-absolute top-0 end-0 m-2" onclick="window.copyToClipboard()" aria-label="Copier la clé">
                                        <i class="fas fa-copy" aria-hidden="true"></i>
                                    </button>
                                </div>
                                <div class="mt-3 text-center">
                                    <button class="btn btn-secondary btn-sm" onclick="window.downloadKey()" aria-label="Télécharger la clé">
                                        <i class="fas fa-download me-2" aria-hidden="true"></i>Télécharger Fichier
                                    </button>
                                </div>
                            </div>
                            
                            <div id="noResultContainer" class="flex-grow-1 d-flex flex-column justify-content-center align-items-center text-center py-5">
                                <i class="fas fa-key display-1 text-ghost-muted mb-3" aria-hidden="true"></i>
                                <h3 class="text-ghost-secondary mb-2">Aucune clé générée</h3>
                                <p class="text-ghost-muted">Configurez les paramètres à gauche pour commencer.</p>
                                <div class="progress-ghost mt-3" style="width: 100px;">
                                    <div class="progress-bar bg-blackhat-muted" style="width: 0%;"></div>
                                </div>
                                <div class="mt-4">
                                    <small class="text-ghost-muted">
                                        <i class="fas fa-info-circle me-1" aria-hidden="true"></i>
                                        Tous les types de clés sont conformes aux standards NIST 2025
                                    </small>
                                </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
        </div>
    </main>

    <!-- Footer -->
    <footer class="py-4 text-center" style="background: var(--bg-primary); border-top: 1px solid var(--border-primary);">
        <div class="container">
            <div class="row align-items-center">
                <div class="col-lg-6">
                    <h5 class="text-gradient">
                        <i class="fas fa-ghost me-2"></i>Ghost Cyber Universe
                    </h5>
                    <p class="text-ghost-secondary mb-0">Génération cryptographique sécurisée et éthique.</p>
                </div>
                <div class="col-lg-6 text-lg-end">
                    <p class="text-ghost-secondary mb-0">
                        <i class="fas fa-shield-alt me-2"></i>
                        Sécurisé • Conforme • Open Source
                    </p>
                </div>
            </div>
        </div>
    </footer>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
    <script src="/static/js/complete-key-types.js?v=20251004-1" defer></script>
    <script src="/static/js/cyber-animations.js?v=20251004-1" defer></script>
    <script src="/static/js/generate.js?v=20251004-1" defer></script>
    <script>
        // Enhanced Form Logic with Real-time Validation and UX Feedback
        document.addEventListener('DOMContentLoaded', () => {
            const form = document.getElementById('keyGenerationForm');
            const progress = document.getElementById('configProgress');
            const progressText = document.getElementById('progressText');
            const btn = document.getElementById('generateBtn');
            let stepCount = 0;

            // Dynamic field updates - Intégration avec KeyGenerator améliorée
            const keyTypeSelect = document.getElementById('keyType');
            if (keyTypeSelect) {
                keyTypeSelect.addEventListener('change', (e) => {
                const keyType = e.target.value;
                console.log('Type de clé sélectionné:', keyType);
                    
                    // Validation du type de clé
                    if (keyType) {
                        e.target.setAttribute('aria-invalid', 'false');
                        e.target.classList.remove('is-invalid');
                    } else {
                        e.target.setAttribute('aria-invalid', 'true');
                        e.target.classList.add('is-invalid');
                    }
                
                if (window.KeyGeneratorInstance) {
                    window.KeyGeneratorInstance.currentKeyType = keyType;
                    window.KeyGeneratorInstance.updateAlgorithms(keyType);
                    window.KeyGeneratorInstance.updateKeySize(keyType);
                    window.KeyGeneratorInstance.updateOutputFormats(keyType);
                    window.KeyGeneratorInstance.toggleSpecialParams(keyType);
                    window.KeyGeneratorInstance.updateProgress();
                } else {
                    // Fallback immédiat - s'assurer que toutes les fonctions sont appelées
                    updateAlgorithmOptions(keyType);
                    updateKeySizeForType(keyType);
                    updateOutputFormatsForType(keyType);
                    toggleDynamicFields(keyType);
                    // La progression sera mise à jour dans updateAlgorithmOptions
                }
                    
                    // Mettre à jour l'aperçu en temps réel
                    updatePreview();
                    updateSecurityAudit();
                    updatePerformanceMetrics();
            });
            }
            
            // Listener pour l'algorithme
            const algorithmSelect = document.getElementById('algorithm');
            if (algorithmSelect) {
                algorithmSelect.addEventListener('change', (e) => {
                const algorithm = e.target.value;
                console.log('Algorithme sélectionné:', algorithm);
                    
                    // Validation de l'algorithme
                    if (algorithm) {
                        e.target.setAttribute('aria-invalid', 'false');
                        e.target.classList.remove('is-invalid');
                    } else {
                        e.target.setAttribute('aria-invalid', 'true');
                        e.target.classList.add('is-invalid');
                    }
                
                if (window.KeyGeneratorInstance) {
                    window.KeyGeneratorInstance.updateKeySizeForAlgorithm(algorithm);
                } else {
                    updateKeySizeForAlgorithm(algorithm);
                }
                updateProgress();
                    
                    // Mettre à jour l'aperçu en temps réel
                    updatePreview();
                    updateSecurityAudit();
                    updatePerformanceMetrics();
                });
            }

            // Listener pour la protection par mot de passe
            const passwordProtectedCheckbox = document.getElementById('passwordProtected');
            if (passwordProtectedCheckbox) {
                passwordProtectedCheckbox.addEventListener('change', (e) => {
                    const passwordSection = document.getElementById('passwordSection');
                    if (passwordSection) {
                        passwordSection.style.display = e.target.checked ? 'block' : 'none';
                    }
                updateProgress();
                    
                    // Mettre à jour l'audit de sécurité
                    updateSecurityAudit();
            });
            }

            // Listener pour la taille de clé
            const keySizeInput = document.getElementById('keySize');
            if (keySizeInput) {
                keySizeInput.addEventListener('change', (e) => {
                    // Validation de la taille
                    const value = parseInt(e.target.value);
                    if (value < 128 || value > 8192) {
                        e.target.setAttribute('aria-invalid', 'true');
                        e.target.classList.add('is-invalid');
                    } else {
                        e.target.setAttribute('aria-invalid', 'false');
                        e.target.classList.remove('is-invalid');
                    }
                updateProgress();
                    
                    // Mettre à jour l'aperçu en temps réel
                    updatePreview();
                    updateSecurityAudit();
                    updatePerformanceMetrics();
                });
            }

            // Listener pour la glissière de taille de clé
            const keySizeRange = document.getElementById('keySizeRange');
            if (keySizeRange && keySizeInput) {
                keySizeRange.addEventListener('input', (e) => {
                    keySizeInput.value = e.target.value;
                    // Déclencher la validation
                    keySizeInput.dispatchEvent(new Event('change'));
                });
            }

            // Listener pour le format de sortie
            const outputFormatSelect = document.getElementById('outputFormat');
            if (outputFormatSelect) {
                outputFormatSelect.addEventListener('change', (e) => {
                    const format = e.target.value;
                    if (format) {
                        e.target.setAttribute('aria-invalid', 'false');
                        e.target.classList.remove('is-invalid');
                    } else {
                        e.target.setAttribute('aria-invalid', 'true');
                        e.target.classList.add('is-invalid');
                    }
                    updateProgress();
                    
                    // Mettre à jour l'aperçu en temps réel
                    updatePreview();
                    updateSecurityAudit();
                    updatePerformanceMetrics();
                });
            }

            // Password strength with zxcvbn - Amélioré
            const passwordInput = document.getElementById('password');
            const strengthBar = document.getElementById('strengthBar');
            const strengthText = document.getElementById('strengthText');
            
            if (passwordInput) {
            passwordInput.addEventListener('input', (e) => {
                    const password = e.target.value;
                    
                    // Validation de base
                    if (password.length > 0 && password.length < 12) {
                        e.target.setAttribute('aria-invalid', 'true');
                        e.target.classList.add('is-invalid');
                    } else {
                        e.target.setAttribute('aria-invalid', 'false');
                        e.target.classList.remove('is-invalid');
                    }
                    
                if (window.KeyGeneratorInstance) {
                        window.KeyGeneratorInstance.validatePasswordStrength(password);
                } else {
                    // Fallback validation
                        validatePasswordFallback(password);
                }
                updateProgress();
                    
                    // Mettre à jour l'audit de sécurité
                    updateSecurityAudit();
            });
            }
            
            function validatePasswordFallback(password) {
                if (!strengthBar || !strengthText) return;
                
                if (!password) {
                    strengthBar.style.width = '0%';
                    strengthBar.className = 'progress-bar bg-secondary';
                    strengthText.textContent = 'Aucune';
                    return;
                }
                
                // Validation basique si zxcvbn n'est pas disponible
                let score = 0;
                if (password.length >= 8) score++;
                if (password.length >= 12) score++;
                if (/[A-Z]/.test(password)) score++;
                if (/[0-9]/.test(password)) score++;
                if (/[^A-Za-z0-9]/.test(password)) score++;
                score = Math.min(4, score);
                
                if (typeof zxcvbn !== 'undefined') {
                    const strength = zxcvbn(password);
                    score = Math.max(score, strength.score);
                }
                
                strengthBar.style.width = `${(score / 4) * 100}%`;
                strengthBar.className = `progress-bar bg-${['danger', 'warning', 'info', 'success'][score]}`;
                strengthText.textContent = ['Faible', 'Moyen', 'Bon', 'Excellent'][score];
            }

            // Generate strong password
            const generatePasswordBtn = document.getElementById('generatePasswordBtn');
            if (generatePasswordBtn && passwordInput) {
                generatePasswordBtn.addEventListener('click', () => {
                const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()';
                let pwd = '';
                for (let i = 0; i < 16; i++) pwd += chars[Math.floor(Math.random() * chars.length)];
                passwordInput.value = pwd;
                passwordInput.dispatchEvent(new Event('input'));
            });
            }

            // Toggle password visibility
            const togglePasswordBtn = document.getElementById('togglePasswordBtn');
            if (togglePasswordBtn && passwordInput) {
                togglePasswordBtn.addEventListener('click', (e) => {
                const icon = e.target.querySelector('i');
                const type = passwordInput.type === 'password' ? 'text' : 'password';
                passwordInput.type = type;
                icon.className = type === 'password' ? 'fas fa-eye' : 'fas fa-eye-slash';
            });
            }

            // Form submission with enhanced validation and loading
            if (form) {
            form.addEventListener('submit', async (e) => {
                e.preventDefault();
                
                // Utiliser KeyGenerator si disponible
                if (window.KeyGeneratorInstance) {
                    if (window.KeyGeneratorInstance.validateForm(form)) {
                        await window.KeyGeneratorInstance.generateKey();
                    }
                    return;
                }
                
                // Fallback validation
                if (!form.checkValidity()) {
                    e.stopPropagation();
                    form.classList.add('was-validated');
                    showAlert('Veuillez corriger les erreurs dans le formulaire.', 'warning');
                    return;
                }
                
                // Validation personnalisée
                const formData = new FormData(form);
                const keyType = formData.get('key_type');
                const algorithm = formData.get('algorithm');
                const passwordProtected = formData.get('password_protected') === 'on';
                const password = formData.get('password');
                
                if (!keyType) {
                    showAlert('Type de clé requis', 'danger');
                    return;
                }
                
                if (!algorithm) {
                    showAlert('Algorithme requis', 'danger');
                    return;
                }
                
                if (passwordProtected && (!password || password.length < 12)) {
                    showAlert('Mot de passe faible (minimum 12 caractères)', 'danger');
                    return;
                }
                
                const submitBtn = btn.querySelector('#generateBtnText');
                const spinner = document.getElementById('loadingSpinner');
                
                if (submitBtn) submitBtn.style.display = 'none';
                if (spinner) spinner.classList.remove('d-none');
                btn.disabled = true;
                
                try {
                    // Préparer les données JSON
                    const formData = new FormData(form);
                    const keyData = {
                        keyType: formData.get('key_type'),
                        algorithm: formData.get('algorithm'),
                        keySize: parseInt(formData.get('key_size')),
                        outputFormat: formData.get('output_format'),
                        passwordProtected: formData.get('password_protected') === 'on',
                        password: formData.get('password') || '',
                        specialParams: {
                            tlsVersion: formData.get('tls_version') || '',
                            kdfAlgorithm: formData.get('kdf_algorithm') || ''
                        }
                    };
                    const requestData = {
                        key_type: keyType,
                        algorithm: algorithm,
                        key_size: parseInt(formData.get('key_size')) || 256,
                        output_format: formData.get('output_format') || 'pem',
                        password_protected: passwordProtected,
                        password: password || null
                    };
                    
                    // Ajouter paramètres spéciaux
                    if (keyType === 'tls_cert') {
                        Object.assign(requestData, {
                            common_name: formData.get('common_name') || 'Ghost Cyber Universe',
                            organization: formData.get('organization') || 'Ghost Cyber Universe',
                            country: formData.get('country') || 'FR',
                            email: formData.get('email') || '',
                            validity_days: parseInt(formData.get('validity_days')) || 365
                        });
                    } else if (keyType === 'kdf') {
                        Object.assign(requestData, {
                            iterations: parseInt(formData.get('iterations')) || 100000,
                            salt_length: parseInt(formData.get('salt_length')) || 32
                        });
                    }
                    
                    const response = await fetch('/api/generate-key', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-Requested-With': 'XMLHttpRequest'
                        },
                        body: JSON.stringify(requestData)
                    });
                    
                    const data = await response.json();
                    
                    if (!response.ok) {
                        throw new Error(data.detail || `Erreur ${response.status}: ${response.statusText}`);
                    }
                    
                    displayResult(data);
                    showAlert('Clé générée avec succès !', 'success');
                    
                    // Ajouter à l'historique
                    addToKeyHistory(keyData);
                    
                } catch (error) {
                    console.error('Erreur génération:', error);
                    showAlert(`Erreur lors de la génération: ${error.message}`, 'danger');
                } finally {
                    if (submitBtn) submitBtn.style.display = 'inline';
                    if (spinner) spinner.classList.add('d-none');
                    btn.disabled = false;
                }
            });
            }

            function updateProgress() {
                if (window.KeyGeneratorInstance) {
                    window.KeyGeneratorInstance.updateProgress();
                    return;
                }
                
                // Fallback progress calculation
                const keyTypeEl = document.getElementById('keyType');
                const algorithmEl = document.getElementById('algorithm');
                const keySizeEl = document.getElementById('keySize');
                const outputFormatEl = document.getElementById('outputFormat');
                const passwordProtectedEl = document.getElementById('passwordProtected');
                const passwordEl = document.getElementById('password');
                
                if (!keyTypeEl || !algorithmEl || !keySizeEl || !outputFormatEl || !passwordProtectedEl) {
                    return; // Éléments non trouvés
                }
                
                const keyTypeValue = keyTypeEl.value;
                const algorithmValue = algorithmEl.value;
                const keySizeValue = parseInt(keySizeEl.value) || 0;
                const outputFormatValue = outputFormatEl.value;
                const passwordProtected = passwordProtectedEl.checked;
                const passwordValue = passwordEl ? passwordEl.value : '';
                
                let passwordValid = true;
                if (passwordProtected) {
                    if (typeof zxcvbn !== 'undefined' && passwordValue) {
                        passwordValid = zxcvbn(passwordValue).score >= 3;
                    } else {
                        // Validation basique
                        passwordValid = passwordValue && passwordValue.length >= 12;
                    }
                }
                
                const steps = [
                    !!keyTypeValue,
                    !!algorithmValue,
                    keySizeValue >= 128,
                    !!outputFormatValue,
                    !passwordProtected || passwordValid
                ].filter(Boolean).length;
                
                stepCount = steps;
                if (progress) {
                    progress.style.width = `${(steps / 5) * 100}%`;
                }
                if (progressText) {
                    progressText.textContent = `Progression : ${steps}/5 étapes`;
                }
                if (btn) {
                    btn.disabled = steps < 5;
                }
            }

            function updateAlgorithmOptions(type) {
                console.log('updateAlgorithmOptions appelée avec:', type);
                
                const select = document.getElementById('algorithm');
                if (!select) {
                    console.error('Élément algorithm non trouvé');
                    return;
                }
                
                select.innerHTML = '<option value="">Sélectionnez un algorithme...</option>';
                select.disabled = true;
                
                if (!type) {
                    console.log('Aucun type fourni');
                    return;
                }
                
                // Configuration locale étendue de fallback
                const options = {
                    symmetric: [
                        { value: 'aes256', text: 'AES-256-GCM (Recommandé)', desc: 'Standard NIST, haute performance' },
                        { value: 'chacha20poly1305', text: 'ChaCha20-Poly1305', desc: 'Moderne, résistant aux attaques temporelles' },
                        { value: 'aes192', text: 'AES-192-GCM', desc: 'Sécurité intermédiaire' },
                        { value: 'camellia256', text: 'Camellia-256', desc: 'Alternative ISO/IEC' }
                    ],
                    rsa: [
                        { value: 'rsa3072', text: 'RSA-3072 (Recommandé 2025)', desc: 'Minimum pour nouveaux systèmes' },
                        { value: 'rsa4096', text: 'RSA-4096', desc: 'Haute sécurité, performances réduites' },
                        { value: 'rsa2048', text: 'RSA-2048 (Legacy)', desc: 'Phase-out 2030' }
                    ],
                    ecc: [
                        { value: 'secp256r1', text: 'NIST P-256 (secp256r1)', desc: 'Standard, équiv. RSA-3072' },
                        { value: 'secp384r1', text: 'NIST P-384 (secp384r1)', desc: 'Haute sécurité' },
                        { value: 'secp521r1', text: 'NIST P-521 (secp521r1)', desc: 'Sécurité maximale' },
                        { value: 'secp256k1', text: 'secp256k1 (Bitcoin)', desc: 'Crypto-monnaies' }
                    ],
                    ed25519: [
                        { value: 'ed25519', text: 'Ed25519', desc: 'Signatures rapides et sécurisées' }
                    ],
                    x25519: [
                        { value: 'x25519', text: 'X25519', desc: 'Échange de clés ECDH moderne' }
                    ],
                    ssh: [
                        { value: 'ed25519', text: 'Ed25519 (Recommandé)', desc: 'Rapide et sécurisé' },
                        { value: 'ecdsap256', text: 'ECDSA P-256', desc: 'Compatible large' },
                        { value: 'rsa3072', text: 'RSA-3072', desc: 'Legacy mais sécurisé' }
                    ],
                    tls_cert: [
                        { value: 'ecdsap256', text: 'ECDSA P-256 (Recommandé)', desc: 'Performance optimale' },
                        { value: 'rsa3072', text: 'RSA-3072', desc: 'Compatibilité étendue' },
                        { value: 'ed25519', text: 'Ed25519', desc: 'Moderne, support limité' }
                    ],
                    bip39: [
                        { value: 'bip3924', text: 'BIP39-24 mots', desc: '256 bits, recommandé sécurité' },
                        { value: 'bip3918', text: 'BIP39-18 mots', desc: '192 bits, sécurité moyenne' },
                        { value: 'bip3912', text: 'BIP39-12 mots', desc: '128 bits, éviter pour 2025' }
                    ],
                    jwt: [
                        { value: 'es256', text: 'ES256 (ECDSA P-256)', desc: 'Recommandé pour performance' },
                        { value: 'hs512', text: 'HS512 (HMAC SHA-512)', desc: 'Symétrique, haute sécurité' },
                        { value: 'eddsa', text: 'EdDSA (Ed25519)', desc: 'Moderne, rapide' },
                        { value: 'rs256', text: 'RS256 (RSA SHA-256)', desc: 'Legacy, éviter' }
                    ],
                    hmac: [
                        { value: 'hmacsha512', text: 'HMAC-SHA-512 (Recommandé)', desc: 'Sécurité maximale' },
                        { value: 'hmacsha256', text: 'HMAC-SHA-256', desc: 'Standard, performance' },
                        { value: 'hmacsha384', text: 'HMAC-SHA-384', desc: 'Sécurité intermédiaire' }
                    ],
                    totp: [
                        { value: 'totpsha256', text: 'TOTP-SHA-256 (Recommandé)', desc: 'Standard moderne' },
                        { value: 'totpsha1', text: 'TOTP-SHA-1', desc: 'Legacy, compatible' },
                        { value: 'totpsha512', text: 'TOTP-SHA-512', desc: 'Haute sécurité' }
                    ],
                    kdf: [
                        { value: 'argon2id', text: 'Argon2id (Recommandé)', desc: 'Gagnant PHC, résistant GPU' },
                        { value: 'pbkdf2', text: 'PBKDF2-HMAC-SHA256', desc: 'Standard NIST' },
                        { value: 'scrypt', text: 'scrypt', desc: 'Résistant ASIC' }
                    ],
                    post_quantum: [
                        { value: 'mlkem768', text: 'ML-KEM-768 (Kyber)', desc: 'NIST FIPS 203, KEM standard' },
                        { value: 'mldsa65', text: 'ML-DSA-65 (Dilithium)', desc: 'NIST FIPS 204, signatures' },
                        { value: 'hqc192', text: 'HQC-192', desc: 'Code-based, NIST 2025' },
                        { value: 'slhdsasha2192f', text: 'SLH-DSA-SHA2-192f', desc: 'Hash-based, NIST FIPS 205' }
                    ]
                };
                
                const typeOptions = options[type];
                if (typeOptions && typeOptions.length > 0) {
                    typeOptions.forEach(opt => {
                        const option = document.createElement('option');
                        option.value = opt.value;
                        option.textContent = opt.text;
                        option.title = opt.desc;
                        select.appendChild(option);
                    });
                    
                    // Débloquer l'algorithme
                    select.disabled = false;
                    
                    // Sélectionner le premier par défaut
                    select.value = typeOptions[0].value;
                    
                    console.log(`${typeOptions.length} algorithmes ajoutés pour ${type}, algorithme débloqué`);
                    
                    // Déclencher l'événement change pour mettre à jour la taille et la progression
                    select.dispatchEvent(new Event('change'));
                    
                    // Mettre à jour la progression immédiatement
                    updateProgress();
                } else {
                    console.warn('Aucun algorithme trouvé pour le type:', type);
                    select.disabled = true;
                }
            }

            // Nouvelles fonctions utilitaires
            function updateKeySizeForType(type) {
                const keySizeSelect = document.getElementById('keySize');
                
                const defaultSizes = {
                    'symmetric': 256,
                    'rsa': 3072,
                    'ecc': 256,
                    'ed25519': 256,
                    'x25519': 256,
                    'ssh': 256,
                    'tls_cert': 256,
                    'bip39': 256,
                    'jwt': 256,
                    'hmac': 512,
                    'totp': 256,
                    'kdf': 256,
                    'post_quantum': 1184
                };
                
                const size = defaultSizes[type] || 256;
                if (keySizeSelect) keySizeSelect.value = size;
                
                console.log(`Taille mise à jour pour ${type}: ${size} bits`);
            }
            
            function updateKeySizeForAlgorithm(algorithm) {
                const keySizeSelect = document.getElementById('keySize');
                
                const algorithmSizes = {
                    'aes256': 256, 'aes192': 192, 'aes128': 128,
                    'chacha20poly1305': 256, 'camellia256': 256,
                    'rsa2048': 2048, 'rsa3072': 3072, 'rsa4096': 4096,
                    'secp256r1': 256, 'secp384r1': 384, 'secp521r1': 521,
                    'secp256k1': 256, 'ed25519': 256, 'x25519': 256,
                    'ecdsap256': 256, 'ecdsap384': 384, 'ecdsap521': 521,
                    'hmacsha256': 256, 'hmacsha384': 384, 'hmacsha512': 512,
                    'totpsha256': 256, 'totpsha512': 512,
                    'argon2id': 256, 'pbkdf2': 256, 'scrypt': 256,
                    'mlkem768': 1184, 'mldsa65': 1952, 'hqc192': 3328,
                    'slhdsasha2192f': 48
                };
                
                const size = algorithmSizes[algorithm] || 256;
                if (keySizeSelect) keySizeSelect.value = size;
                
                console.log(`Taille mise à jour: ${size} bits pour ${algorithm}`);
            }
            
            function updateOutputFormatsForType(type) {
                const formatSelect = document.getElementById('outputFormat');
                if (!formatSelect) return;
                
                const formatMap = {
                    'symmetric': [['base64', 'Base64'], ['hex', 'Hexadécimal'], ['raw', 'Binaire']],
                    'rsa': [['pem', 'PEM'], ['der', 'DER'], ['pkcs8', 'PKCS#8'], ['jwk', 'JWK']],
                    'ecc': [['pem', 'PEM'], ['der', 'DER'], ['pkcs8', 'PKCS#8'], ['jwk', 'JWK']],
                    'ed25519': [['pem', 'PEM'], ['der', 'DER'], ['pkcs8', 'PKCS#8'], ['jwk', 'JWK']],
                    'x25519': [['pem', 'PEM'], ['der', 'DER'], ['pkcs8', 'PKCS#8'], ['jwk', 'JWK']],
                    'ssh': [['openssh', 'OpenSSH'], ['pem', 'PEM']],
                    'tls_cert': [['pem', 'PEM'], ['pkcs12', 'PKCS#12'], ['der', 'DER']],
                    'bip39': [['bip39_mnemonic', 'BIP39 Mnémonique'], ['hex', 'Hexadécimal']],
                    'jwt': [['jwk', 'JWK'], ['base64', 'Base64'], ['jose', 'JOSE']],
                    'hmac': [['base64', 'Base64'], ['hex', 'Hexadécimal']],
                    'totp': [['base64', 'Base64'], ['hex', 'Hexadécimal']],
                    'kdf': [['base64', 'Base64'], ['hex', 'Hexadécimal']],
                    'post_quantum': [['pem', 'PEM'], ['jwk', 'JWK'], ['jose', 'JOSE']]
                };
                
                const formats = formatMap[type] || [['pem', 'PEM'], ['base64', 'Base64']];
                formatSelect.innerHTML = '';
                
                formats.forEach(([value, text]) => {
                    const option = document.createElement('option');
                    option.value = value;
                    option.textContent = text;
                    formatSelect.appendChild(option);
                });
                
                // Sélectionner le premier par défaut
                if (formats.length > 0) {
                    formatSelect.value = formats[0][0];
                }
                
                console.log(`Formats de sortie mis à jour pour ${type}: ${formats.length} options`);
            }
            
            function toggleDynamicFields(type) {
                const tlsParams = document.getElementById('tlsParams');
                const kdfParams = document.getElementById('kdfParams');
                
                // Masquer tous d'abord
                if (tlsParams) tlsParams.style.display = 'none';
                if (kdfParams) kdfParams.style.display = 'none';
                
                // Afficher selon le type
                if (type === 'tls_cert' && tlsParams) {
                    tlsParams.style.display = 'block';
                    console.log('Paramètres TLS affichés');
                } else if (type === 'kdf' && kdfParams) {
                    kdfParams.style.display = 'block';
                    console.log('Paramètres KDF affichés');
                }
                
                // Mettre à jour la progression après changement
                updateProgress();
            }

            function displayResult(data) {
                if (window.KeyGeneratorInstance) {
                    window.KeyGeneratorInstance.displayResult(data);
                    return;
                }
                
                // Fallback display
                const container = document.getElementById('resultContainer');
                const content = document.getElementById('resultContent');
                const noResultContainer = document.getElementById('noResultContainer');
                
                if (!container || !content) {
                    console.error('Elements résultats manquants');
                    return;
                }
                
                let resultHtml = `
                    <div class="mb-4 p-3 bg-tertiary rounded" role="status">
                        <h5 class="text-gradient mb-2">
                            <i class="fas fa-key me-2" aria-hidden="true"></i>
                            ${(data.key_type || data.type || 'Clé').toUpperCase()} - ${(data.format || data.output_format || 'PEM').toUpperCase()}
                        </h5>
                        <div class="row small text-ghost-secondary">
                            <div class="col-md-6">
                                <p><strong>Algorithme:</strong> ${data.algorithm || 'N/A'}</p>
                                <p><strong>Taille:</strong> ${data.key_size || data.size || 'N/A'} bits</p>
                                <p><strong>Fingerprint:</strong> ${data.fingerprint || 'N/A'}</p>
                            </div>
                            <div class="col-md-6">
                                <p><strong>Créé:</strong> ${data.created_at ? new Date(data.created_at).toLocaleString('fr-FR') : new Date().toLocaleString('fr-FR')}</p>
                                ${data.expires_at ? `<p><strong>Expire:</strong> ${new Date(data.expires_at).toLocaleString('fr-FR')}</p>` : ''}
                                <p><strong>UUID:</strong> ${data.uuid ? data.uuid.slice(0,8) + '...' : 'N/A'}</p>
                            </div>
                        </div>
                    </div>
                `;
                
                // Clé principale - gérer différents formats de réponse
                const keyData = data.key_data || data.key || data.private_key || data.mnemonic || data.certificate;
                if (!keyData) {
                    console.error('Aucune donnée de clé trouvée dans la réponse:', data);
                    resultHtml += '<div class="alert alert-warning">Aucune clé générée trouvée dans la réponse.</div>';
                } else {
                    const displayKey = typeof keyData === 'string' ? keyData : JSON.stringify(keyData, null, 2);
                
                    resultHtml += `
                        <div class="code-block-ghost position-relative mb-4" id="keyDataBlock">
                            <pre class="mb-0 overflow-auto" style="background: var(--bg-tertiary); padding: 1rem; border-radius: var(--radius-md); font-size: 0.875rem; max-height: 300px;">${displayKey}</pre>
                            <button class="btn btn-sm btn-outline-light position-absolute top-0 end-0 m-2" onclick="window.copyToClipboard()" aria-label="Copier la clé">
                                <i class="fas fa-copy" aria-hidden="true"></i>
                            </button>
                            <button class="btn btn-sm btn-outline-success position-absolute top-0 start-0 m-2" onclick="window.downloadKey()" aria-label="Télécharger">
                                <i class="fas fa-download" aria-hidden="true"></i>
                            </button>
                        </div>
                    `;
                }
                
                // Clé publique si disponible
                if (data.public_key) {
                    resultHtml += `
                        <div class="code-block-ghost position-relative mb-4">
                            <h6 class="text-white mb-2">Clé Publique</h6>
                            <pre class="mb-0 overflow-auto" style="background: var(--bg-tertiary); padding: 1rem; border-radius: var(--radius-md); font-size: 0.875rem; max-height: 200px;">${data.public_key}</pre>
                            <button class="btn btn-sm btn-outline-light position-absolute top-0 end-0 m-2" onclick="copyPublicKey('${data.public_key.replace(/'/g, "\\'")}')">  
                                <i class="fas fa-copy"></i>
                            </button>
                        </div>
                    `;
                }
                
                // Métadonnées
                if (data.metadata) {
                    resultHtml += `
                        <details class="mb-4">
                            <summary class="text-gradient cursor-pointer">Métadonnées Détaillées <i class="fas fa-chevron-down ms-1"></i></summary>
                            <div class="code-block-ghost mt-2">
                                <pre class="mb-0 overflow-auto" style="background: var(--bg-tertiary); padding: 1rem; border-radius: var(--radius-md); font-size: 0.875rem; max-height: 200px;">${JSON.stringify(data.metadata, null, 2)}</pre>
                            </div>
                        </details>
                    `;
                }
                
                content.innerHTML = resultHtml;
                container.classList.remove('d-none');
                if (noResultContainer) noResultContainer.classList.add('d-none');
                container.scrollIntoView({ behavior: 'smooth' });
                container.focus();
            }

            function showAlert(message, type = 'info') {
                if (window.KeyGeneratorInstance) {
                    window.KeyGeneratorInstance.showAlert(message, type);
                    return;
                }
                
                // Fallback alert
                const alertDiv = document.createElement('div');
                alertDiv.className = `alert alert-${type} alert-dismissible fade show position-fixed`;
                alertDiv.style.cssText = `
                    top: 20px; right: 20px; z-index: 9999; max-width: 400px;
                    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
                `;
                alertDiv.setAttribute('role', 'alert');
                
                const iconMap = {
                    success: 'fas fa-check-circle text-success',
                    danger: 'fas fa-times-circle text-danger', 
                    warning: 'fas fa-exclamation-triangle text-warning',
                    info: 'fas fa-info-circle text-info'
                };
                
                alertDiv.innerHTML = `
                    <div class="d-flex align-items-center">
                        <i class="${iconMap[type] || iconMap.info} me-2"></i>
                        <div class="flex-grow-1">${message}</div>
                        <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Fermer"></button>
                    </div>
                `;
                
                document.body.appendChild(alertDiv);
                
                // Auto-remove after 5 seconds
                setTimeout(() => {
                    if (alertDiv.parentNode) {
                        alertDiv.remove();
                    }
                }, 5000);
                
                // Bootstrap dismiss functionality
                if (typeof bootstrap !== 'undefined') {
                    new bootstrap.Alert(alertDiv);
                }
            }
            
            // Fonction utilitaire pour copier la clé publique
            window.copyPublicKey = function(publicKey) {
                navigator.clipboard.writeText(publicKey).then(() => {
                    showAlert('Clé publique copiée !', 'success');
                }).catch(() => {
                    showAlert('Erreur de copie', 'danger');
                });
            };

            // ===== FONCTIONS D'APERÇU EN TEMPS RÉEL =====
            
            /**
             * Initialise le panneau d'aperçu en temps réel
             */
            function initializePreviewPanel() {
                console.log('Initialisation du panneau d\'aperçu...');
                updatePreview();
                updateSecurityAudit();
                updatePerformanceMetrics();
            }
            
            /**
             * Met à jour l'aperçu de la configuration
             */
            function updatePreview() {
                const keyType = document.getElementById('keyType')?.value || '';
                const algorithm = document.getElementById('algorithm')?.value || '';
                const keySize = document.getElementById('keySize')?.value || '256';
                const outputFormat = document.getElementById('outputFormat')?.value || 'pem';
                
                // Mettre à jour les éléments d'aperçu
                updatePreviewElement('previewKeyType', keyType ? getKeyTypeDisplayName(keyType) : 'Non sélectionné');
                updatePreviewElement('previewAlgorithm', algorithm ? getAlgorithmDisplayName(algorithm) : 'Non sélectionné');
                updatePreviewElement('previewKeySize', `${keySize} bits`);
                updatePreviewElement('previewFormat', getFormatDisplayName(outputFormat));
                
                // Afficher les exemples d'usage si un type est sélectionné
                if (keyType) {
                    showUsageExamples(keyType, algorithm);
                } else {
                    hideUsageExamples();
                }
            }
            
            /**
             * Met à jour un élément d'aperçu avec animation
             */
            function updatePreviewElement(elementId, value) {
                const element = document.getElementById(elementId);
                if (element) {
                    element.style.opacity = '0.5';
                    setTimeout(() => {
                        element.textContent = value;
                        element.style.opacity = '1';
                    }, 150);
                }
            }
            
            /**
             * Met à jour l'audit de sécurité
             */
            function updateSecurityAudit() {
                const keyType = document.getElementById('keyType')?.value || '';
                const algorithm = document.getElementById('algorithm')?.value || '';
                const keySize = parseInt(document.getElementById('keySize')?.value) || 256;
                const passwordProtected = document.getElementById('passwordProtected')?.checked || false;
                const password = document.getElementById('password')?.value || '';
                
                const securityData = calculateSecurityScore(keyType, algorithm, keySize, passwordProtected, password);
                
                // Mettre à jour le score
                updateSecurityScore(securityData.score, securityData.level);
                
                // Mettre à jour les recommandations
                updateSecurityRecommendations(securityData.recommendations);
            }
            
            /**
             * Calcule le score de sécurité
             */
            function calculateSecurityScore(keyType, algorithm, keySize, passwordProtected, password) {
                let score = 0;
                let recommendations = [];
                
                if (!keyType) {
                    return { score: 0, level: 'poor', recommendations: ['Sélectionnez un type de clé pour commencer l\'audit'] };
                }
                
                // Score basé sur le type de clé
                const keyTypeScores = {
                    'symmetric': 85,
                    'ecc': 90,
                    'ed25519': 95,
                    'x25519': 90,
                    'ssh': 85,
                    'tls_cert': 80,
                    'jwt': 75,
                    'hmac': 80,
                    'totp': 70,
                    'kdf': 85,
                    'post_quantum': 100,
                    'rsa': 60,
                    'bip39': 50
                };
                
                score = keyTypeScores[keyType] || 50;
                
                // Ajustements basés sur l'algorithme
                if (algorithm) {
                    if (algorithm.includes('256') && keySize >= 256) score += 5;
                    if (algorithm.includes('512') && keySize >= 512) score += 10;
                    if (algorithm.includes('3072') && keySize >= 3072) score += 15;
                    if (algorithm.includes('4096') && keySize >= 4096) score += 20;
                }
                
                // Ajustements basés sur la taille
                if (keySize < 128) {
                    score -= 30;
                    recommendations.push({ type: 'danger', message: 'Taille de clé trop faible (< 128 bits)' });
                } else if (keySize < 256) {
                    score -= 10;
                    recommendations.push({ type: 'warning', message: 'Taille de clé recommandée : 256+ bits' });
                }
                
                // Ajustements pour la protection par mot de passe
                if (passwordProtected) {
                    if (password && password.length >= 12) {
                        score += 10;
                        recommendations.push({ type: 'good', message: 'Mot de passe fort configuré' });
                    } else {
                        score -= 20;
                        recommendations.push({ type: 'danger', message: 'Mot de passe faible ou manquant' });
                    }
                }
                
                // Recommandations spécifiques par type
                if (keyType === 'rsa' && keySize < 3072) {
                    recommendations.push({ type: 'warning', message: 'RSA < 3072 bits déprécié (NIST 2025)' });
                }
                
                if (keyType === 'bip39') {
                    recommendations.push({ type: 'warning', message: 'Stockez hors-ligne, jamais en ligne' });
                }
                
                if (keyType === 'post_quantum') {
                    recommendations.push({ type: 'good', message: 'Résistant aux ordinateurs quantiques' });
                }
                
                // Déterminer le niveau
                let level = 'poor';
                if (score >= 90) level = 'excellent';
                else if (score >= 75) level = 'good';
                else if (score >= 60) level = 'fair';
                
                return { score: Math.max(0, Math.min(100, score)), level, recommendations };
            }
            
            /**
             * Met à jour l'affichage du score de sécurité
             */
            function updateSecurityScore(score, level) {
                const scoreValue = document.getElementById('securityScoreValue');
                const scoreBar = document.getElementById('securityScoreBar');
                
                if (scoreValue) {
                    scoreValue.textContent = `${score}/100`;
                    scoreValue.className = `text-white security-score-${level}`;
                }
                
                if (scoreBar) {
                    scoreBar.style.width = `${score}%`;
                    scoreBar.className = `progress-bar bg-${level}`;
                }
            }
            
            /**
             * Met à jour les recommandations de sécurité
             */
            function updateSecurityRecommendations(recommendations) {
                const container = document.getElementById('securityRecommendations');
                if (!container) return;
                
                if (recommendations.length === 0) {
                    container.innerHTML = '<div class="text-ghost-muted">Configuration sécurisée</div>';
                    return;
                }
                
                let html = '';
                recommendations.forEach(rec => {
                    html += `
                        <div class="recommendation-item recommendation-${rec.type}">
                            <i class="fas fa-${rec.type === 'good' ? 'check-circle' : rec.type === 'warning' ? 'exclamation-triangle' : 'times-circle'} me-2"></i>
                            ${rec.message}
                        </div>
                    `;
                });
                
                container.innerHTML = html;
            }
            
            /**
             * Met à jour les métriques de performance
             */
            function updatePerformanceMetrics() {
                const keyType = document.getElementById('keyType')?.value || '';
                const algorithm = document.getElementById('algorithm')?.value || '';
                const keySize = parseInt(document.getElementById('keySize')?.value) || 256;
                
                const metrics = calculatePerformanceMetrics(keyType, algorithm, keySize);
                
                updatePerformanceElement('estimatedTime', metrics.time);
                updatePerformanceElement('estimatedSize', metrics.size);
            }
            
            /**
             * Calcule les métriques de performance
             */
            function calculatePerformanceMetrics(keyType, algorithm, keySize) {
                let time = '~1-3s';
                let size = '~1-2 KB';
                
                if (!keyType) {
                    return { time, size };
                }
                
                // Temps de génération estimé
                const timeEstimates = {
                    'symmetric': '~0.1-0.5s',
                    'ecc': '~0.2-1s',
                    'ed25519': '~0.1-0.5s',
                    'x25519': '~0.1-0.5s',
                    'ssh': '~0.2-1s',
                    'tls_cert': '~0.5-2s',
                    'jwt': '~0.1-0.3s',
                    'hmac': '~0.1-0.3s',
                    'totp': '~0.1-0.3s',
                    'kdf': '~0.5-3s',
                    'post_quantum': '~1-5s',
                    'rsa': keySize >= 4096 ? '~2-10s' : '~0.5-3s',
                    'bip39': '~0.1-0.5s'
                };
                
                time = timeEstimates[keyType] || '~1-3s';
                
                // Taille estimée
                const sizeEstimates = {
                    'symmetric': '~32-64 bytes',
                    'ecc': '~32-64 bytes',
                    'ed25519': '~32 bytes',
                    'x25519': '~32 bytes',
                    'ssh': '~200-500 bytes',
                    'tls_cert': '~1-5 KB',
                    'jwt': '~100-500 bytes',
                    'hmac': '~32-64 bytes',
                    'totp': '~20-40 bytes',
                    'kdf': '~32-64 bytes',
                    'post_quantum': '~1-10 KB',
                    'rsa': keySize >= 4096 ? '~3-5 KB' : '~1-3 KB',
                    'bip39': '~200-400 bytes'
                };
                
                size = sizeEstimates[keyType] || '~1-2 KB';
                
                return { time, size };
            }
            
            /**
             * Met à jour un élément de performance
             */
            function updatePerformanceElement(elementId, value) {
                const element = document.getElementById(elementId);
                if (element) {
                    element.textContent = value;
                }
            }
            
            /**
             * Affiche les exemples d'usage
             */
            function showUsageExamples(keyType, algorithm) {
                const examplesContainer = document.getElementById('usageExamples');
                const codeElement = document.getElementById('exampleCode');
                
                if (!examplesContainer || !codeElement) return;
                
                const examples = getUsageExamples(keyType, algorithm);
                codeElement.innerHTML = examples;
                examplesContainer.style.display = 'block';
            }
            
            /**
             * Masque les exemples d'usage
             */
            function hideUsageExamples() {
                const examplesContainer = document.getElementById('usageExamples');
                if (examplesContainer) {
                    examplesContainer.style.display = 'none';
                }
            }
            
            /**
             * Obtient les exemples d'usage pour un type de clé
             */
            function getUsageExamples(keyType, algorithm) {
                const examples = {
                    'symmetric': `
// Chiffrement AES-256-GCM
const crypto = require('crypto');
const key = crypto.randomBytes(32);
const iv = crypto.randomBytes(16);
const cipher = crypto.createCipher('aes-256-gcm', key);
cipher.setAAD(Buffer.from('additional data'));
let encrypted = cipher.update('Hello World', 'utf8', 'hex');
encrypted += cipher.final('hex');
const tag = cipher.getAuthTag();`,
                    
                    'rsa': `
// Génération de clé RSA
const crypto = require('crypto');
const { publicKey, privateKey } = crypto.generateKeyPairSync('rsa', {
    modulusLength: 3072,
    publicKeyEncoding: { type: 'spki', format: 'pem' },
    privateKeyEncoding: { type: 'pkcs8', format: 'pem' }
});`,
                    
                    'ecc': `
// Clé ECC P-256
const crypto = require('crypto');
const { publicKey, privateKey } = crypto.generateKeyPairSync('ec', {
    namedCurve: 'prime256v1',
    publicKeyEncoding: { type: 'spki', format: 'pem' },
    privateKeyEncoding: { type: 'sec1', format: 'pem' }
});`,
                    
                    'ed25519': `
// Signature Ed25519
const crypto = require('crypto');
const { publicKey, privateKey } = crypto.generateKeyPairSync('ed25519');
const sign = crypto.createSign('sha256');
sign.update('data to sign');
const signature = sign.sign(privateKey, 'hex');`,
                    
                    'ssh': `
# Génération de clé SSH Ed25519
ssh-keygen -t ed25519 -C "your_email@example.com"

# Ajout à l'agent SSH
ssh-add ~/.ssh/id_ed25519

# Copie de la clé publique
cat ~/.ssh/id_ed25519.pub`,
                    
                    'tls_cert': `
# Génération de certificat TLS
openssl req -x509 -newkey rsa:3072 -keyout key.pem -out cert.pem -days 365 -nodes

# Ou avec ECDSA
openssl req -x509 -newkey ec:<(openssl ecparam -name prime256v1) -keyout key.pem -out cert.pem -days 365 -nodes`,
                    
                    'jwt': `
// JWT avec ES256
const jwt = require('jsonwebtoken');
const token = jwt.sign({ userId: 123 }, privateKey, { 
    algorithm: 'ES256',
    expiresIn: '1h' 
});

// Vérification
const decoded = jwt.verify(token, publicKey, { algorithms: ['ES256'] });`,
                    
                    'bip39': `
// Génération de mnémonique BIP39
const bip39 = require('bip39');
const mnemonic = bip39.generateMnemonic(256); // 24 mots
const seed = bip39.mnemonicToSeedSync(mnemonic);

// IMPORTANT: Stocker hors-ligne uniquement !`,
                    
                    'post_quantum': `
// ML-KEM (Kyber) - Post-quantum
const { generateKeyPair } = require('@noble/curves/ed25519');
// Note: Implémentation expérimentale
// Utiliser des bibliothèques spécialisées pour la production`
                };
                
                return examples[keyType] || 'Exemples non disponibles pour ce type de clé.';
            }
            
            /**
             * Fonctions utilitaires pour les noms d'affichage
             */
            function getKeyTypeDisplayName(keyType) {
                const names = {
                    'symmetric': 'Clés Symétriques',
                    'rsa': 'RSA (Legacy)',
                    'ecc': 'ECC (Courbes Elliptiques)',
                    'ed25519': 'Ed25519',
                    'x25519': 'X25519',
                    'ssh': 'Clés SSH',
                    'tls_cert': 'Certificats TLS',
                    'bip39': 'BIP39 (Crypto-monnaie)',
                    'jwt': 'JWT/API Tokens',
                    'hmac': 'HMAC',
                    'totp': 'TOTP/OTP',
                    'kdf': 'KDF (Dérivation)',
                    'post_quantum': 'Post-Quantique'
                };
                return names[keyType] || keyType;
            }
            
            function getAlgorithmDisplayName(algorithm) {
                return algorithm.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase());
            }
            
            function getFormatDisplayName(format) {
                const names = {
                    'pem': 'PEM',
                    'der': 'DER',
                    'base64': 'Base64',
                    'hex': 'Hexadécimal',
                    'raw': 'Binaire',
                    'jwk': 'JWK',
                    'pkcs8': 'PKCS#8',
                    'pkcs12': 'PKCS#12',
                    'openssh': 'OpenSSH',
                    'bip39_mnemonic': 'BIP39 Mnémonique',
                    'jose': 'JOSE'
                };
                return names[format] || format.toUpperCase();
            }
            
            // ===== FIN DES FONCTIONS D'APERÇU =====
            
            // ===== FONCTIONS D'HISTORIQUE DES CLÉS =====
            
            /**
             * Initialise l'historique des clés
             */
            function initializeKeyHistory() {
                console.log('Initialisation de l\'historique des clés...');
                loadKeyHistory();
                setupHistoryEventListeners();
            }
            
            /**
             * Configure les événements de l'historique
             */
            function setupHistoryEventListeners() {
                const clearHistoryBtn = document.getElementById('clearHistoryBtn');
                if (clearHistoryBtn) {
                    clearHistoryBtn.addEventListener('click', clearKeyHistory);
                }
            }
            
            /**
             * Charge l'historique depuis le stockage local
             */
            function loadKeyHistory() {
                try {
                    const history = JSON.parse(localStorage.getItem('keyGeneratorHistory') || '[]');
                    displayKeyHistory(history);
                } catch (error) {
                    console.error('Erreur lors du chargement de l\'historique:', error);
                    displayKeyHistory([]);
                }
            }
            
            /**
             * Sauvegarde l'historique dans le stockage local
             */
            function saveKeyHistory(history) {
                try {
                    localStorage.setItem('keyGeneratorHistory', JSON.stringify(history));
                } catch (error) {
                    console.error('Erreur lors de la sauvegarde de l\'historique:', error);
                }
            }
            
            /**
             * Affiche l'historique des clés
             */
            function displayKeyHistory(history) {
                const historyList = document.getElementById('historyList');
                const noHistoryMessage = document.getElementById('noHistoryMessage');
                
                if (!historyList || !noHistoryMessage) return;
                
                if (history.length === 0) {
                    historyList.style.display = 'none';
                    noHistoryMessage.style.display = 'block';
                    return;
                }
                
                historyList.style.display = 'block';
                noHistoryMessage.style.display = 'none';
                
                // Trier par date (plus récent en premier)
                history.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
                
                let html = '';
                history.forEach((keyData, index) => {
                    html += createHistoryItemHTML(keyData, index);
                });
                
                historyList.innerHTML = html;
                
                // Ajouter les événements aux éléments
                history.forEach((keyData, index) => {
                    const item = document.getElementById(`history-item-${index}`);
                    if (item) {
                        item.addEventListener('click', () => selectHistoryItem(keyData, index));
                    }
                    
                    const copyBtn = document.getElementById(`copy-history-${index}`);
                    if (copyBtn) {
                        copyBtn.addEventListener('click', (e) => {
                            e.stopPropagation();
                            copyHistoryKey(keyData);
                        });
                    }
                    
                    const deleteBtn = document.getElementById(`delete-history-${index}`);
                    if (deleteBtn) {
                        deleteBtn.addEventListener('click', (e) => {
                            e.stopPropagation();
                            deleteHistoryItem(index);
                        });
                    }
                });
            }
            
            /**
             * Crée le HTML pour un élément d'historique
             */
            function createHistoryItemHTML(keyData, index) {
                const timestamp = new Date(keyData.timestamp);
                const timeStr = timestamp.toLocaleString('fr-FR', {
                    day: '2-digit',
                    month: '2-digit',
                    year: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                });
                
                const securityLevel = keyData.securityLevel || 'poor';
                const securityClass = `security-${securityLevel}`;
                
                return `
                    <div class="history-item" id="history-item-${index}">
                        <div class="history-item-header">
                            <div class="history-item-type">${getKeyTypeDisplayName(keyData.keyType)}</div>
                            <div class="history-item-time">${timeStr}</div>
                        </div>
                        <div class="history-item-details">
                            <div><strong>Algorithme:</strong> ${keyData.algorithm || 'N/A'}</div>
                            <div><strong>Taille:</strong> ${keyData.keySize || 'N/A'} bits</div>
                            <div><strong>Format:</strong> ${getFormatDisplayName(keyData.outputFormat || 'pem')}</div>
                            ${keyData.fingerprint ? `<div class="key-fingerprint">${keyData.fingerprint}</div>` : ''}
                        </div>
                        <div class="history-item-actions">
                            <span class="security-badge ${securityClass}">${securityLevel}</span>
                            <button class="btn btn-sm btn-outline-primary" id="copy-history-${index}" title="Copier la clé">
                                <i class="fas fa-copy"></i>
                            </button>
                            <button class="btn btn-sm btn-outline-danger" id="delete-history-${index}" title="Supprimer">
                                <i class="fas fa-trash"></i>
                            </button>
                        </div>
                    </div>
                `;
            }
            
            /**
             * Ajoute une nouvelle clé à l'historique
             */
            function addToKeyHistory(keyData) {
                try {
                    const history = JSON.parse(localStorage.getItem('keyGeneratorHistory') || '[]');
                    
                    // Créer l'entrée d'historique
                    const historyEntry = {
                        id: Date.now().toString(),
                        timestamp: new Date().toISOString(),
                        keyType: keyData.keyType,
                        algorithm: keyData.algorithm,
                        keySize: keyData.keySize,
                        outputFormat: keyData.outputFormat,
                        fingerprint: generateKeyFingerprint(keyData),
                        securityLevel: calculateSecurityLevel(keyData),
                        metadata: {
                            passwordProtected: keyData.passwordProtected || false,
                            specialParams: keyData.specialParams || {}
                        }
                    };
                    
                    // Ajouter au début de la liste
                    history.unshift(historyEntry);
                    
                    // Limiter à 50 entrées maximum
                    if (history.length > 50) {
                        history.splice(50);
                    }
                    
                    // Sauvegarder et afficher
                    saveKeyHistory(history);
                    displayKeyHistory(history);
                    
                    // Mettre à jour les analytics
                    updateAnalytics();
                    updateMonitoringMetrics();
                    
                    console.log('Clé ajoutée à l\'historique:', historyEntry);
                } catch (error) {
                    console.error('Erreur lors de l\'ajout à l\'historique:', error);
                }
            }
            
            /**
             * Génère un fingerprint pour la clé
             */
            function generateKeyFingerprint(keyData) {
                const data = `${keyData.keyType}-${keyData.algorithm}-${keyData.keySize}-${keyData.outputFormat}`;
                return btoa(data).substring(0, 16).toUpperCase();
            }
            
            /**
             * Calcule le niveau de sécurité pour l'historique
             */
            function calculateSecurityLevel(keyData) {
                const securityData = calculateSecurityScore(
                    keyData.keyType,
                    keyData.algorithm,
                    keyData.keySize,
                    keyData.passwordProtected || false,
                    ''
                );
                return securityData.level;
            }
            
            /**
             * Sélectionne un élément d'historique
             */
            function selectHistoryItem(keyData, index) {
                // Retirer la classe active de tous les éléments
                document.querySelectorAll('.history-item').forEach(item => {
                    item.classList.remove('active');
                });
                
                // Ajouter la classe active à l'élément sélectionné
                const selectedItem = document.getElementById(`history-item-${index}`);
                if (selectedItem) {
                    selectedItem.classList.add('active');
                }
                
                // Afficher les détails dans la section des résultats
                displayHistoryKeyDetails(keyData);
            }
            
            /**
             * Affiche les détails d'une clé de l'historique
             */
            function displayHistoryKeyDetails(keyData) {
                const resultContent = document.getElementById('resultContent');
                const noResultContainer = document.getElementById('noResultContainer');
                
                if (!resultContent || !noResultContainer) return;
                
                noResultContainer.style.display = 'none';
                resultContent.style.display = 'block';
                
                const timestamp = new Date(keyData.timestamp);
                const timeStr = timestamp.toLocaleString('fr-FR', {
                    day: '2-digit',
                    month: '2-digit',
                    year: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit'
                });
                
                resultContent.innerHTML = `
                    <div class="alert-ghost alert-ghost-info mb-3">
                        <i class="fas fa-history me-2"></i>
                        <strong>Clé de l'historique</strong> - Générée le ${timeStr}
                    </div>
                    <div class="key-details mb-3">
                        <div class="row g-3">
                            <div class="col-md-6">
                                <div class="detail-item">
                                    <label class="text-ghost-secondary small">Type de clé</label>
                                    <div class="text-white">${getKeyTypeDisplayName(keyData.keyType)}</div>
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="detail-item">
                                    <label class="text-ghost-secondary small">Algorithme</label>
                                    <div class="text-white">${keyData.algorithm || 'N/A'}</div>
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="detail-item">
                                    <label class="text-ghost-secondary small">Taille</label>
                                    <div class="text-white">${keyData.keySize || 'N/A'} bits</div>
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="detail-item">
                                    <label class="text-ghost-secondary small">Format</label>
                                    <div class="text-white">${getFormatDisplayName(keyData.outputFormat || 'pem')}</div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="alert-ghost alert-ghost-warning">
                        <i class="fas fa-exclamation-triangle me-2"></i>
                        <strong>Note:</strong> Cette clé provient de l'historique. Le contenu de la clé n'est pas stocké pour des raisons de sécurité.
                    </div>
                `;
            }
            
            /**
             * Copie une clé de l'historique
             */
            function copyHistoryKey(keyData) {
                showAlert('Impossible de copier: le contenu de la clé n\'est pas stocké pour des raisons de sécurité.', 'warning');
            }
            
            /**
             * Supprime un élément de l'historique
             */
            function deleteHistoryItem(index) {
                if (!confirm('Êtes-vous sûr de vouloir supprimer cette entrée de l\'historique ?')) {
                    return;
                }
                
                try {
                    const history = JSON.parse(localStorage.getItem('keyGeneratorHistory') || '[]');
                    history.splice(index, 1);
                    saveKeyHistory(history);
                    displayKeyHistory(history);
                    showAlert('Entrée supprimée de l\'historique', 'success');
                } catch (error) {
                    console.error('Erreur lors de la suppression:', error);
                    showAlert('Erreur lors de la suppression', 'danger');
                }
            }
            
            /**
             * Efface tout l'historique
             */
            function clearKeyHistory() {
                if (!confirm('Êtes-vous sûr de vouloir effacer tout l\'historique des clés ?')) {
                    return;
                }
                
                try {
                    localStorage.removeItem('keyGeneratorHistory');
                    displayKeyHistory([]);
                    showAlert('Historique effacé', 'success');
                } catch (error) {
                    console.error('Erreur lors de l\'effacement:', error);
                    showAlert('Erreur lors de l\'effacement', 'danger');
                }
            }
            
            // ===== FIN DES FONCTIONS D'HISTORIQUE =====
            
            // ===== FONCTIONS D'EXPORT AVANCÉ =====
            
            /**
             * Affiche le modal d'export avancé
             */
            function showAdvancedExport() {
                const resultContent = document.getElementById('resultContent');
                if (!resultContent || resultContent.style.display === 'none') {
                    showAlert('Aucune clé générée à exporter', 'warning');
                    return;
                }
                
                const modal = new bootstrap.Modal(document.getElementById('advancedExportModal'));
                modal.show();
            }
            
            /**
             * Génère un QR Code pour la clé
             */
            function generateQRCode() {
                const resultContent = document.getElementById('resultContent');
                const qrContainer = document.getElementById('qrCodeContainer');
                const downloadBtn = document.getElementById('downloadQRBtn');
                
                if (!resultContent || !qrContainer) {
                    showAlert('Aucune clé à convertir en QR Code', 'warning');
                    return;
                }
                
                const keyText = resultContent.textContent || resultContent.innerText;
                if (!keyText || keyText.trim().length === 0) {
                    showAlert('Contenu de clé vide', 'warning');
                    return;
                }
                
                try {
                    // Nettoyer le contenu pour le QR Code
                    const cleanKeyText = keyText.replace(/\s+/g, ' ').trim();
                    
                    // Générer le QR Code
                    QRCode.toCanvas(qrContainer, cleanKeyText, {
                        width: 200,
                        height: 200,
                        color: {
                            dark: '#ff0000',
                            light: '#000000'
                        },
                        margin: 2,
                        errorCorrectionLevel: 'M'
                    }, function (error) {
                        if (error) {
                            console.error('Erreur génération QR Code:', error);
                            showAlert('Erreur lors de la génération du QR Code', 'danger');
                        } else {
                            downloadBtn.disabled = false;
                            showAlert('QR Code généré avec succès !', 'success');
                        }
                    });
                } catch (error) {
                    console.error('Erreur QR Code:', error);
                    showAlert('Erreur lors de la génération du QR Code', 'danger');
                }
            }
            
            /**
             * Télécharge le QR Code
             */
            function downloadQRCode() {
                const qrContainer = document.getElementById('qrCodeContainer');
                const canvas = qrContainer.querySelector('canvas');
                
                if (!canvas) {
                    showAlert('Aucun QR Code à télécharger', 'warning');
                    return;
                }
                
                try {
                    const link = document.createElement('a');
                    link.download = 'key-qrcode.png';
                    link.href = canvas.toDataURL();
                    link.click();
                    showAlert('QR Code téléchargé !', 'success');
                } catch (error) {
                    console.error('Erreur téléchargement QR:', error);
                    showAlert('Erreur lors du téléchargement', 'danger');
                }
            }
            
            /**
             * Exporte en formats multiples
             */
            function exportMultipleFormats() {
                const resultContent = document.getElementById('resultContent');
                if (!resultContent || resultContent.style.display === 'none') {
                    showAlert('Aucune clé à exporter', 'warning');
                    return;
                }
                
                const keyText = resultContent.textContent || resultContent.innerText;
                if (!keyText || keyText.trim().length === 0) {
                    showAlert('Contenu de clé vide', 'warning');
                    return;
                }
                
                const formats = [];
                if (document.getElementById('exportPEM').checked) formats.push('pem');
                if (document.getElementById('exportDER').checked) formats.push('der');
                if (document.getElementById('exportBase64').checked) formats.push('base64');
                if (document.getElementById('exportHex').checked) formats.push('hex');
                if (document.getElementById('exportJWK').checked) formats.push('jwk');
                
                if (formats.length === 0) {
                    showAlert('Sélectionnez au moins un format', 'warning');
                    return;
                }
                
                formats.forEach((format, index) => {
                    setTimeout(() => {
                        downloadKeyInFormat(keyText, format);
                    }, index * 500); // Délai entre les téléchargements
                });
                
                showAlert(`${formats.length} format(s) exporté(s) !`, 'success');
            }
            
            /**
             * Télécharge une clé dans un format spécifique
             */
            function downloadKeyInFormat(keyText, format) {
                try {
                    let content = keyText;
                    let filename = 'key';
                    let mimeType = 'text/plain';
                    
                    switch (format) {
                        case 'pem':
                            filename = 'key.pem';
                            mimeType = 'application/x-pem-file';
                            break;
                        case 'der':
                            // Conversion PEM vers DER (simulation)
                            content = btoa(keyText);
                            filename = 'key.der';
                            mimeType = 'application/x-x509-ca-cert';
                            break;
                        case 'base64':
                            content = btoa(keyText);
                            filename = 'key.b64';
                            mimeType = 'text/plain';
                            break;
                        case 'hex':
                            content = Array.from(keyText).map(c => c.charCodeAt(0).toString(16).padStart(2, '0')).join('');
                            filename = 'key.hex';
                            mimeType = 'text/plain';
                            break;
                        case 'jwk':
                            content = JSON.stringify({
                                kty: "RSA",
                                use: "sig",
                                key_ops: ["sign", "verify"],
                                alg: "RS256",
                                n: btoa(keyText.substring(0, 100)),
                                e: "AQAB"
                            }, null, 2);
                            filename = 'key.jwk';
                            mimeType = 'application/json';
                            break;
                    }
                    
                    const blob = new Blob([content], { type: mimeType });
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = filename;
                    link.click();
                    URL.revokeObjectURL(url);
                } catch (error) {
                    console.error(`Erreur export ${format}:`, error);
                }
            }
            
            /**
             * Crée un package ZIP avec tous les formats
             */
            function createExportPackage() {
                const resultContent = document.getElementById('resultContent');
                if (!resultContent || resultContent.style.display === 'none') {
                    showAlert('Aucune clé à exporter', 'warning');
                    return;
                }
                
                const keyText = resultContent.textContent || resultContent.innerText;
                if (!keyText || keyText.trim().length === 0) {
                    showAlert('Contenu de clé vide', 'warning');
                    return;
                }
                
                if (typeof JSZip === 'undefined') {
                    showAlert('Bibliothèque ZIP non disponible', 'warning');
                    return;
                }
                
                try {
                    const zip = new JSZip();
                    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                    
                    // Ajouter les formats sélectionnés
                    if (document.getElementById('exportPEM').checked) {
                        zip.file('key.pem', keyText);
                    }
                    if (document.getElementById('exportDER').checked) {
                        zip.file('key.der', btoa(keyText));
                    }
                    if (document.getElementById('exportBase64').checked) {
                        zip.file('key.b64', btoa(keyText));
                    }
                    if (document.getElementById('exportHex').checked) {
                        const hexContent = Array.from(keyText).map(c => c.charCodeAt(0).toString(16).padStart(2, '0')).join('');
                        zip.file('key.hex', hexContent);
                    }
                    if (document.getElementById('exportJWK').checked) {
                        const jwkContent = JSON.stringify({
                            kty: "RSA",
                            use: "sig",
                            key_ops: ["sign", "verify"],
                            alg: "RS256",
                            n: btoa(keyText.substring(0, 100)),
                            e: "AQAB"
                        }, null, 2);
                        zip.file('key.jwk', jwkContent);
                    }
                    
                    // Ajouter un fichier README
                    const readmeContent = `# Export de Clé Cryptographique
Généré le: ${new Date().toLocaleString('fr-FR')}
Source: Ghost Cyber Universe - Key Generator

## Formats inclus:
${document.getElementById('exportPEM').checked ? '- PEM (key.pem)' : ''}
${document.getElementById('exportDER').checked ? '- DER (key.der)' : ''}
${document.getElementById('exportBase64').checked ? '- Base64 (key.b64)' : ''}
${document.getElementById('exportHex').checked ? '- Hexadécimal (key.hex)' : ''}
${document.getElementById('exportJWK').checked ? '- JWK (key.jwk)' : ''}

## Sécurité:
- Stockez ces fichiers dans un endroit sécurisé
- Ne partagez jamais vos clés privées
- Utilisez des mots de passe forts pour protéger les fichiers
`;
                    zip.file('README.txt', readmeContent);
                    
                    // Générer et télécharger le ZIP
                    zip.generateAsync({ type: 'blob' }).then(function (content) {
                        const link = document.createElement('a');
                        link.href = URL.createObjectURL(content);
                        link.download = `key-export-${timestamp}.zip`;
                        link.click();
                        URL.revokeObjectURL(link.href);
                        showAlert('Package ZIP créé et téléchargé !', 'success');
                    });
                } catch (error) {
                    console.error('Erreur création ZIP:', error);
                    showAlert('Erreur lors de la création du package ZIP', 'danger');
                }
            }
            
            /**
             * Partage vers un gestionnaire de mots de passe
             */
            function shareToPasswordManager() {
                const resultContent = document.getElementById('resultContent');
                if (!resultContent || resultContent.style.display === 'none') {
                    showAlert('Aucune clé à partager', 'warning');
                    return;
                }
                
                const keyText = resultContent.textContent || resultContent.innerText;
                if (!keyText || keyText.trim().length === 0) {
                    showAlert('Contenu de clé vide', 'warning');
                    return;
                }
                
                // Copier dans le presse-papiers
                navigator.clipboard.writeText(keyText).then(() => {
                    showAlert('Clé copiée ! Collez-la dans votre gestionnaire de mots de passe.', 'success');
                }).catch(() => {
                    showAlert('Erreur lors de la copie', 'danger');
                });
            }
            
            /**
             * Génère une configuration SSH
             */
            function generateSSHConfig() {
                const resultContent = document.getElementById('resultContent');
                if (!resultContent || resultContent.style.display === 'none') {
                    showAlert('Aucune clé SSH à configurer', 'warning');
                    return;
                }
                
                const keyText = resultContent.textContent || resultContent.innerText;
                if (!keyText || keyText.trim().length === 0) {
                    showAlert('Contenu de clé vide', 'warning');
                    return;
                }
                
                const sshConfig = `# Configuration SSH
# Ajoutez ceci à votre fichier ~/.ssh/config

Host myserver
    HostName your-server.com
    User your-username
    IdentityFile ~/.ssh/id_ed25519
    IdentitiesOnly yes

# Ou utilisez directement:
ssh -i ~/.ssh/id_ed25519 user@your-server.com

# Pour ajouter la clé à l'agent SSH:
ssh-add ~/.ssh/id_ed25519

# Votre clé publique:
${keyText}`;
                
                const blob = new Blob([sshConfig], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = 'ssh-config.txt';
                link.click();
                URL.revokeObjectURL(url);
                showAlert('Configuration SSH générée !', 'success');
            }
            
            /**
             * Génère une configuration TLS
             */
            function generateTLSConfig() {
                const resultContent = document.getElementById('resultContent');
                if (!resultContent || resultContent.style.display === 'none') {
                    showAlert('Aucune clé TLS à configurer', 'warning');
                    return;
                }
                
                const keyText = resultContent.textContent || resultContent.innerText;
                if (!keyText || keyText.trim().length === 0) {
                    showAlert('Contenu de clé vide', 'warning');
                    return;
                }
                
                const tlsConfig = `# Configuration TLS/SSL
# Nginx
server {
    listen 443 ssl http2;
    server_name your-domain.com;
    
    ssl_certificate /path/to/your/cert.pem;
    ssl_certificate_key /path/to/your/key.pem;
    
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES256-GCM-SHA384;
    ssl_prefer_server_ciphers off;
    ssl_session_cache shared:SSL:10m;
    ssl_session_timeout 10m;
}

# Apache
<VirtualHost *:443>
    ServerName your-domain.com
    SSLEngine on
    SSLCertificateFile /path/to/your/cert.pem
    SSLCertificateKeyFile /path/to/your/key.pem
    SSLCertificateChainFile /path/to/your/chain.pem
</VirtualHost>

# Votre clé privée:
${keyText}`;
                
                const blob = new Blob([tlsConfig], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = 'tls-config.txt';
                link.click();
                URL.revokeObjectURL(url);
                showAlert('Configuration TLS générée !', 'success');
            }
            
            // ===== FIN DES FONCTIONS D'EXPORT AVANCÉ =====
            
            // ===== FONCTIONS DE GESTION DES CLÉS =====
            
            /**
             * Initialise les outils de gestion des clés
             */
            function initializeKeyManagement() {
                console.log('Initialisation des outils de gestion...');
                setupManagementEventListeners();
                loadKeyManagementData();
                updateMonitoringMetrics();
            }
            
            /**
             * Configure les événements de gestion
             */
            function setupManagementEventListeners() {
                // Rotation frequency change
                const rotationFrequency = document.getElementById('rotationFrequency');
                if (rotationFrequency) {
                    rotationFrequency.addEventListener('change', (e) => {
                        const customDiv = document.getElementById('customRotationDiv');
                        if (e.target.value === 'custom') {
                            customDiv.style.display = 'block';
                        } else {
                            customDiv.style.display = 'none';
                        }
                    });
                }
                
                // Revocation reason change
                const revocationReason = document.getElementById('revocationReason');
                if (revocationReason) {
                    revocationReason.addEventListener('change', (e) => {
                        const customReasonDiv = document.getElementById('customReasonDiv');
                        if (e.target.value === 'other') {
                            customReasonDiv.style.display = 'block';
                        } else {
                            customReasonDiv.style.display = 'none';
                        }
                    });
                }
                
                // Key selection for revocation
                const keyToRevoke = document.getElementById('keyToRevoke');
                if (keyToRevoke) {
                    keyToRevoke.addEventListener('change', (e) => {
                        const revokeBtn = document.getElementById('revokeBtn');
                        if (revokeBtn) {
                            revokeBtn.disabled = !e.target.value;
                        }
                    });
                }
            }
            
            /**
             * Charge les données de gestion des clés
             */
            function loadKeyManagementData() {
                loadKeysForRevocation();
                loadRotationSchedule();
                updateAnalytics();
            }
            
            /**
             * Charge les clés disponibles pour révocation
             */
            function loadKeysForRevocation() {
                try {
                    const history = JSON.parse(localStorage.getItem('keyGeneratorHistory') || '[]');
                    const keySelect = document.getElementById('keyToRevoke');
                    if (!keySelect) return;
                    
                    // Filtrer les clés non révoquées
                    const activeKeys = history.filter(key => !key.revoked);
                    
                    keySelect.innerHTML = '<option value="">Choisir une clé...</option>';
                    activeKeys.forEach((key, index) => {
                        const option = document.createElement('option');
                        option.value = key.id;
                        option.textContent = `${getKeyTypeDisplayName(key.keyType)} - ${key.algorithm} (${key.keySize} bits)`;
                        keySelect.appendChild(option);
                    });
                } catch (error) {
                    console.error('Erreur chargement clés:', error);
                }
            }
            
            /**
             * Planifie la rotation d'une clé
             */
            function scheduleKeyRotation() {
                const frequency = document.getElementById('rotationFrequency')?.value;
                const customDays = document.getElementById('customRotationDays')?.value;
                const autoRotation = document.getElementById('autoRotation')?.checked;
                const notifications = document.getElementById('rotationNotification')?.checked;
                
                if (!frequency) {
                    showAlert('Sélectionnez une fréquence de rotation', 'warning');
                    return;
                }
                
                const days = frequency === 'custom' ? parseInt(customDays) : parseInt(frequency);
                
                if (days < 1 || days > 3650) {
                    showAlert('Fréquence invalide (1-3650 jours)', 'warning');
                    return;
                }
                
                try {
                    const rotationData = {
                        frequency: days,
                        autoRotation: autoRotation,
                        notifications: notifications,
                        lastUpdate: new Date().toISOString()
                    };
                    
                    localStorage.setItem('keyRotationSettings', JSON.stringify(rotationData));
                    showAlert(`Rotation planifiée : ${days} jours`, 'success');
                    
                    // Mettre à jour l'affichage
                    updateRotationSchedule();
                } catch (error) {
                    console.error('Erreur planification rotation:', error);
                    showAlert('Erreur lors de la planification', 'danger');
                }
            }
            
            /**
             * Affiche le planning de rotation
             */
            function viewRotationSchedule() {
                try {
                    const settings = JSON.parse(localStorage.getItem('keyRotationSettings') || '{}');
                    const history = JSON.parse(localStorage.getItem('keyGeneratorHistory') || '[]');
                    
                    if (!settings.frequency) {
                        showAlert('Aucune rotation planifiée', 'info');
                        return;
                    }
                    
                    let message = `Fréquence de rotation : ${settings.frequency} jours\n`;
                    message += `Rotation automatique : ${settings.autoRotation ? 'Activée' : 'Désactivée'}\n`;
                    message += `Notifications : ${settings.notifications ? 'Activées' : 'Désactivées'}\n\n`;
                    
                    const upcomingRotations = history.filter(key => {
                        if (key.revoked) return false;
                        const createdDate = new Date(key.timestamp);
                        const rotationDate = new Date(createdDate.getTime() + (settings.frequency * 24 * 60 * 60 * 1000));
                        return rotationDate > new Date();
                    });
                    
                    message += `Clés à faire tourner : ${upcomingRotations.length}`;
                    
                    alert(message);
                } catch (error) {
                    console.error('Erreur affichage planning:', error);
                    showAlert('Erreur lors de l\'affichage', 'danger');
                }
            }
            
            /**
             * Met à jour le planning de rotation
             */
            function updateRotationSchedule() {
                // Cette fonction pourrait être étendue pour afficher un calendrier
                console.log('Planning de rotation mis à jour');
            }
            
            /**
             * Révoque une clé
             */
            function revokeKey() {
                const keyId = document.getElementById('keyToRevoke')?.value;
                const reason = document.getElementById('revocationReason')?.value;
                const customReason = document.getElementById('customReason')?.value;
                
                if (!keyId) {
                    showAlert('Sélectionnez une clé à révoquer', 'warning');
                    return;
                }
                
                if (!reason) {
                    showAlert('Sélectionnez une raison de révocation', 'warning');
                    return;
                }
                
                const finalReason = reason === 'other' ? customReason : reason;
                if (!finalReason) {
                    showAlert('Décrivez la raison de révocation', 'warning');
                    return;
                }
                
                if (!confirm(`Êtes-vous sûr de vouloir révoquer cette clé ?\nRaison : ${finalReason}`)) {
                    return;
                }
                
                try {
                    const history = JSON.parse(localStorage.getItem('keyGeneratorHistory') || '[]');
                    const keyIndex = history.findIndex(key => key.id === keyId);
                    
                    if (keyIndex === -1) {
                        showAlert('Clé non trouvée', 'error');
                        return;
                    }
                    
                    // Marquer comme révoquée
                    history[keyIndex].revoked = true;
                    history[keyIndex].revocationDate = new Date().toISOString();
                    history[keyIndex].revocationReason = finalReason;
                    
                    localStorage.setItem('keyGeneratorHistory', JSON.stringify(history));
                    
                    // Mettre à jour l'affichage
                    loadKeysForRevocation();
                    updateMonitoringMetrics();
                    displayKeyHistory(history);
                    
                    showAlert('Clé révoquée avec succès', 'success');
                } catch (error) {
                    console.error('Erreur révocation:', error);
                    showAlert('Erreur lors de la révocation', 'danger');
                }
            }
            
            /**
             * Affiche les clés révoquées
             */
            function viewRevokedKeys() {
                try {
                    const history = JSON.parse(localStorage.getItem('keyGeneratorHistory') || '[]');
                    const revokedKeys = history.filter(key => key.revoked);
                    
                    if (revokedKeys.length === 0) {
                        showAlert('Aucune clé révoquée', 'info');
                        return;
                    }
                    
                    let message = `Clés révoquées (${revokedKeys.length}) :\n\n`;
                    revokedKeys.forEach((key, index) => {
                        const revokeDate = new Date(key.revocationDate).toLocaleDateString('fr-FR');
                        message += `${index + 1}. ${getKeyTypeDisplayName(key.keyType)} - ${key.algorithm}\n`;
                        message += `   Révoquée le : ${revokeDate}\n`;
                        message += `   Raison : ${key.revocationReason}\n\n`;
                    });
                    
                    alert(message);
                } catch (error) {
                    console.error('Erreur affichage clés révoquées:', error);
                    showAlert('Erreur lors de l\'affichage', 'danger');
                }
            }
            
            /**
             * Met à jour les métriques de monitoring
             */
            function updateMonitoringMetrics() {
                try {
                    const history = JSON.parse(localStorage.getItem('keyGeneratorHistory') || '[]');
                    const now = new Date();
                    const thirtyDaysFromNow = new Date(now.getTime() + (30 * 24 * 60 * 60 * 1000));
                    
                    const expiringKeys = history.filter(key => {
                        if (key.revoked) return false;
                        const createdDate = new Date(key.timestamp);
                        const expirationDate = new Date(createdDate.getTime() + (90 * 24 * 60 * 60 * 1000)); // 90 jours par défaut
                        return expirationDate <= thirtyDaysFromNow && expirationDate > now;
                    }).length;
                    
                    const revokedKeys = history.filter(key => key.revoked).length;
                    const activeKeys = history.filter(key => !key.revoked).length;
                    
                    // Mettre à jour l'affichage
                    updateElement('expiringKeys', expiringKeys);
                    updateElement('revokedKeys', revokedKeys);
                    updateElement('activeKeys', activeKeys);
                } catch (error) {
                    console.error('Erreur mise à jour métriques:', error);
                }
            }
            
            /**
             * Met à jour un élément d'affichage
             */
            function updateElement(elementId, value) {
                const element = document.getElementById(elementId);
                if (element) {
                    element.textContent = value;
                }
            }
            
            // ===== FONCTIONS D'ANALYTICS =====
            
            /**
             * Met à jour les analytics
             */
            function updateAnalytics() {
                try {
                    const history = JSON.parse(localStorage.getItem('keyGeneratorHistory') || '[]');
                    const today = new Date().toDateString();
                    const thisMonth = new Date().getMonth();
                    const thisYear = new Date().getFullYear();
                    
                    // Calculer les statistiques
                    const todayKeys = history.filter(key => new Date(key.timestamp).toDateString() === today).length;
                    const thisMonthKeys = history.filter(key => {
                        const keyDate = new Date(key.timestamp);
                        return keyDate.getMonth() === thisMonth && keyDate.getFullYear() === thisYear;
                    }).length;
                    
                    // Types les plus populaires
                    const typeCount = {};
                    history.forEach(key => {
                        typeCount[key.keyType] = (typeCount[key.keyType] || 0) + 1;
                    });
                    const popularTypes = Object.entries(typeCount)
                        .sort(([,a], [,b]) => b - a)
                        .slice(0, 2)
                        .map(([type]) => getKeyTypeDisplayName(type))
                        .join(', ');
                    
                    // Score de sécurité moyen
                    const securityScores = history.map(key => {
                        const securityData = calculateSecurityScore(
                            key.keyType,
                            key.algorithm,
                            key.keySize,
                            key.metadata?.passwordProtected || false,
                            ''
                        );
                        return securityData.score;
                    });
                    const avgSecurityScore = securityScores.length > 0 
                        ? Math.round(securityScores.reduce((a, b) => a + b, 0) / securityScores.length)
                        : 0;
                    
                    // Conformité NIST
                    const nistCompliant = history.filter(key => {
                        if (key.keyType === 'rsa' && key.keySize < 3072) return false;
                        if (key.keyType === 'bip39') return false;
                        return true;
                    }).length;
                    const nistCompliance = history.length > 0 ? Math.round((nistCompliant / history.length) * 100) : 100;
                    
                    // Clés post-quantum
                    const postQuantumKeys = history.filter(key => key.keyType === 'post_quantum').length;
                    const postQuantumPercentage = history.length > 0 ? Math.round((postQuantumKeys / history.length) * 100) : 0;
                    
                    // Protection par mot de passe
                    const passwordProtected = history.filter(key => key.metadata?.passwordProtected).length;
                    const passwordProtectedPercentage = history.length > 0 ? Math.round((passwordProtected / history.length) * 100) : 0;
                    
                    // Mettre à jour l'affichage
                    updateElement('totalKeys', history.length);
                    updateElement('thisMonth', thisMonthKeys);
                    updateElement('todayKeys', todayKeys);
                    updateElement('popularTypes', popularTypes || 'Aucune');
                    updateElement('avgSecurityScore', `${avgSecurityScore}/100`);
                    updateElement('nistCompliance', `${nistCompliance}%`);
                    updateElement('postQuantumKeys', `${postQuantumPercentage}%`);
                    updateElement('passwordProtected', `${passwordProtectedPercentage}%`);
                    
                    // Mettre à jour les barres de progression
                    updateProgressBar('avgSecurityScore', avgSecurityScore);
                    updateProgressBar('nistCompliance', nistCompliance);
                    updateProgressBar('postQuantumKeys', postQuantumPercentage);
                    updateProgressBar('passwordProtected', passwordProtectedPercentage);
                    
                } catch (error) {
                    console.error('Erreur mise à jour analytics:', error);
                }
            }
            
            /**
             * Met à jour une barre de progression
             */
            function updateProgressBar(elementId, percentage) {
                const element = document.getElementById(elementId);
                if (element) {
                    const progressBar = element.parentElement.nextElementSibling?.querySelector('.progress-bar');
                    if (progressBar) {
                        progressBar.style.width = `${percentage}%`;
                    }
                }
            }
            
            // ===== FIN DES FONCTIONS DE GESTION =====

            // Global functions for button access
            window.copyToClipboard = function() {
                const resultContent = document.getElementById('resultContent');
                if (!resultContent) {
                    showAlert('Aucun contenu à copier', 'warning');
                    return;
                }
                
                const preElement = resultContent.querySelector('pre');
                if (!preElement) {
                    showAlert('Aucun contenu à copier', 'warning');
                    return;
                }
                
                const content = preElement.textContent;
                navigator.clipboard.writeText(content).then(() => {
                    showAlert('Clé copiée ! Sécurisez-la immédiatement.', 'success');
                }).catch(() => showAlert('Erreur de copie. Utilisez Ctrl+C.', 'warning'));
            };

            window.downloadKey = function() {
                const resultContent = document.getElementById('resultContent');
                if (!resultContent) {
                    showAlert('Aucun contenu à télécharger', 'warning');
                    return;
                }
                
                const preElement = resultContent.querySelector('pre');
                if (!preElement) {
                    showAlert('Aucun contenu à télécharger', 'warning');
                    return;
                }
                
                const content = preElement.textContent;
                const blob = new Blob([content], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'generated-key.pem';
                a.click();
                URL.revokeObjectURL(url);
                showAlert('Fichier téléchargé !', 'success');
            };

            // Initialisation
            console.log('Initialisation du formulaire...');
            
            // Initialiser la progression
            updateProgress();
            
            // Initialiser l'aperçu en temps réel
            initializePreviewPanel();
            
            // Initialiser l'historique des clés
            initializeKeyHistory();
            
            // Initialiser les outils de gestion
            initializeKeyManagement();
            
            // Ajouter des classes d'animation aux éléments
            setTimeout(() => {
                const formElements = document.querySelectorAll('.form-select, .form-control, .form-check-input');
                formElements.forEach((el, index) => {
                    el.classList.add('animate-fade-in-up');
                    el.style.animationDelay = `${index * 0.1}s`;
                });
            }, 100);
            
            // Vérifier l'état initial des champs
            const keyTypeEl = document.getElementById('keyType');
            const algorithmEl = document.getElementById('algorithm');
            const keySizeEl = document.getElementById('keySize');
            const outputFormatEl = document.getElementById('outputFormat');
            
            if (keyTypeEl && algorithmEl && keySizeEl && outputFormatEl) {
                const keyType = keyTypeEl.value;
                const algorithm = algorithmEl.value;
                const keySize = keySizeEl.value;
                const outputFormat = outputFormatEl.value;
            
            console.log('État initial:', { keyType, algorithm, keySize, outputFormat });
            
            // Si un type de clé est déjà sélectionné, mettre à jour les champs
            if (keyType) {
                console.log('Type de clé déjà sélectionné, mise à jour des champs...');
                updateAlgorithmOptions(keyType);
                updateKeySizeForType(keyType);
                updateOutputFormatsForType(keyType);
                toggleDynamicFields(keyType);
                }
            }
            
            // Vérifier la disponibilité de zxcvbn
            if (typeof zxcvbn === 'undefined') {
                console.warn('zxcvbn non disponible - validation basique utilisée');
            }
            
            // Ajouter des tooltips d'aide
            const tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
            if (typeof bootstrap !== 'undefined' && bootstrap.Tooltip) {
                tooltipTriggerList.map(function (tooltipTriggerEl) {
                    return new bootstrap.Tooltip(tooltipTriggerEl);
                });
            }
            
            // Sync avec KeyGenerator si disponible
            const checkKeyGenerator = () => {
                if (window.KeyGeneratorInstance) {
                    console.log('✅ KeyGenerator détecté - intégration activée');
                    // Synchroniser l'état initial
                    updateProgress();
                } else {
                    console.log('⚠️ Mode fallback activé - utilisation des fonctions locales');
                    // Vérifier que les fonctions fallback sont disponibles
                    if (typeof updateAlgorithmOptions === 'function') {
                        console.log('✅ Fonctions fallback disponibles');
                    } else {
                        console.error('❌ Fonctions fallback manquantes');
                    }
                }
            };
            
            // Vérifier immédiatement et après un délai
            checkKeyGenerator();
            setTimeout(checkKeyGenerator, 1000);
            
            // Test initial pour vérifier que les éléments sont présents
            setTimeout(() => {
                const keyTypeSelect = document.getElementById('keyType');
                const algorithmSelect = document.getElementById('algorithm');
                
                if (keyTypeSelect && algorithmSelect) {
                    console.log('✅ Éléments de formulaire détectés');
                    console.log('Types disponibles:', keyTypeSelect.options.length - 1); // -1 pour l'option vide
                    
                    // Test avec le premier type disponible
                    if (keyTypeSelect.options.length > 1) {
                        const firstType = keyTypeSelect.options[1].value;
                        console.log('Test avec le type:', firstType);
                        updateAlgorithmOptions(firstType);
                        
                        setTimeout(() => {
                            console.log('Algorithmes disponibles:', algorithmSelect.options.length - 1);
                            if (algorithmSelect.options.length > 1) {
                                console.log('✅ Algorithmes chargés avec succès');
                            } else {
                                console.warn('⚠️ Aucun algorithme chargé');
                            }
                        }, 100);
                    }
                } else {
                    console.error('❌ Éléments de formulaire manquants');
                }
            }, 1500);
        });
    </script>
</body>
</html>